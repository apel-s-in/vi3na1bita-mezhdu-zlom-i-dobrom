<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>Витрина Разбита - Между Злом и Добром</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <meta name="description" content="Официальный альбом группы Витрина Разбита. Слушайте онлайн и офлайн.">
  
  <!-- PWA метатеги -->
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#181818" />
  
  <!-- iOS специфичные метатеги -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Витрина">
  <link rel="apple-touch-icon" href="icons/apple-touch-icon.png">
  
  <!-- Предзагрузка критических ресурсов -->
  <link rel="preload" href="img/logo.png" as="image">
  <link rel="preload" href="Cover.png" as="image">
  
  <style>
    :root {
      --primary-bg: #181818;
      --primary-color: #E80100;
      --secondary-color: #4daaff;
      --text-color: #f2f2f2;
      --modal-bg: #252d39;
      --border-color: #394866;
    }
    
    * { box-sizing: border-box; }
    
    html, body { height: 100%; }
    
    body {
      min-height: 100vh;
      background: var(--primary-bg);
      color: var(--text-color);
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      min-width: 100vw;
      padding-top: env(safe-area-inset-top);
    }
    #promocode-block {
      position: fixed;
      left: 0;
      top: 0;
      width: 100vw;
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--primary-bg);
      z-index: 100;
    }
    
    .promo-inner {
      display: flex;
      flex-direction: column;
      align-items: center;
      background: rgba(15,18,24,0.98);
      border-radius: 16px;
      box-shadow: 0 6px 24px #0008;
      padding: 36px 26px 32px 26px;
      min-width: 260px;
      min-height: 170px;
    }
    
    .promo-cover {
      width: 256px;
      height: 256px;
      object-fit: cover;
      border-radius: 12px;
      box-shadow: 0 4px 24px #000c;
      margin-bottom: 19px;
      display: block;
      background: var(--primary-bg);
    }
    
    #promo-inp {
      padding: 10px;
      border-radius: 8px;
      border: 1px solid var(--border-color);
      background: rgba(255,255,255,0.1);
      color: var(--text-color);
      margin: 10px 0;
      width: 100%;
      font-size: 16px;
    }
    
    #promo-btn {
      padding: 10px 20px;
      background: var(--primary-color);
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-weight: bold;
      transition: opacity 0.2s;
    }
    
    #promo-btn:hover:not(:disabled) { opacity: 0.8; }
    #promo-btn:disabled { opacity: 0.5; cursor: not-allowed; }
    
    #promo-error {
      color: #ff6b6b;
      margin-top: 10px;
      font-size: 14px;
    }
    
    .modal-bg {
      position: fixed;
      z-index: 99;
      left: 0;
      top: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.62);
      display: none;
      align-items: center;
      justify-content: center;
      backdrop-filter: blur(4px);
    }
    
    .modal-bg.active { display: flex; animation: fadeIn 0.3s; }
    
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    
    .modal-feedback {
      background: var(--modal-bg);
      border-radius: 14px;
      padding: 34px 20px 21px 20px;
      min-width: 215px;
      box-shadow: 0 4px 32px #0009;
      max-width: 96vw;
      position: relative;
      animation: slideUp 0.3s;
    }
    
    @keyframes slideUp {
      from { transform: translateY(20px); opacity: 0; }
      to { transform: translateY(0); opacity: 1; }
    }
    
    .modal-feedback .bigclose {
      background: none;
      border: none;
      position: absolute;
      top: 13px;
      right: 13px;
      cursor: pointer;
      color: #eee;
      border-radius: 50%;
      width: 32px;
      height: 32px;
      transition: transform 0.2s;
    }
    
    .modal-feedback .bigclose:hover { transform: scale(1.1); }
    .modal-feedback .bigclose svg { width: 31px; height: 31px; }
    
    .hidden { display: none !important; }
    
    #main-block {
      max-width: 420px;
      margin: 0 auto;
      flex: 1 0 auto;
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 100%;
      padding: 0 10px;
    }
    
    header {
      width: 100%;
      text-align: center;
      margin: 0 auto;
    }
    
    #cover-wrap {
      width: 100%;
      max-width: 400px;
      margin: 24px auto 0 auto;
      aspect-ratio: 1/1;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
    }
    
    .cover-gallery-arrow {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      z-index: 2;
      border: none;
      cursor: pointer;
      background: none;
      padding: 0;
      width: 44px;
      height: 44px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: opacity 0.2s;
    }
    
    .cover-gallery-arrow:hover { opacity: 0.8; }
    
    #cover-gallery-arrow-left { left: 7px; }
    #cover-gallery-arrow-right { right: 7px; }
    
    #cover {
      width: 100%;
      max-width: 100%;
      border-radius: 12px;
      aspect-ratio: 1/1;
      object-fit: cover;
      display: block;
      margin: 0;
      box-shadow: 0 4px 24px rgba(0,0,0,0.3);
    }
    
        /* Пульсирующий логотип */
    .logo-bottom {
      max-width: 112px;
      width: 23vw;
      min-width: 66px;
      height: auto;
      display: block;
      margin: 0 auto 15px auto !important;
      cursor: pointer;
      transition: transform 0.1s ease-out;
      will-change: transform;
      transform: translateZ(0);
      transform-origin: center center;
      isolation: isolate;
      z-index: 10;
      position: relative;
    }
        /* Изоляция логотипа от конфликтов */
    #logo-bottom {
      will-change: transform;
      backface-visibility: hidden;
      -webkit-backface-visibility: hidden;
      transform: translateZ(0);
      -webkit-transform: translateZ(0);
    }

    .logo-pulsing {
      animation: none !important;
    }
    
    .logo-pulsing {
      animation: none !important;
    }
    
    .socials-under-cover {
      margin: 14px auto 0 auto;
      width: 100%;
      max-width: 398px;
      text-align: center;
      font-size: 1.03em;
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 12px;
    }
    
    .socials-under-cover a {
      color: var(--secondary-color);
      text-decoration: none;
      transition: color 0.2s;
    }
    
    .socials-under-cover a:hover { color: var(--text-color); }
    
    .track-list {
      margin: 0 auto;
      max-width: 370px;
      width: 100%;
      font-size: 1.05em;
      color: #eee;
      background: none;
      padding: 0;
    }
    
    /* Скрытие треков при фильтре */
    .track-list.filtered .track:not(.is-favorite) {
      display: none !important;
    }
    
    .track {
      display: flex;
      align-items: center;
      padding: 7px 8px;
      border-bottom: 1px solid var(--border-color);
      cursor: pointer;
      transition: background 0.13s;
      background: none;
    }
    
    .track:hover { background: rgba(255,255,255,0.05); }
    .track.current { background: #232b38; }
    
    .tnum {
      min-width: 27px;
      color: #8ab8fd;
    }
    
    .track-title {
      margin-left: 7px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      flex: 1;
    }
    
    .like-star {
      margin-left: auto;
      width: 19px;
      height: 19px;
      cursor: pointer;
      opacity: 0.97;
      border: none;
      background: none;
      padding: 0;
      appearance: none;
      display: inline-block;
      transition: transform 0.2s, filter 0.13s, opacity 0.13s;
    }
    
    .like-star:hover {
      filter: brightness(1.13);
      opacity: 1;
      transform: scale(1.1);
    }
    
    .like-star.animating {
      animation: starPulse 0.3s;
    }
    
    @keyframes starPulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.3); }
    }
    
    .lyrics-player-block {
      width: 100%;
      margin: 8px 0 3px 0;
    }
    
    #lyrics-window {
      width: 100%;
      background: rgba(34,34,34,0.98);
      border-radius: 12px;
      box-shadow: 0 8px 24px #0007;
      overflow: hidden;
      height: 8.5em;
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: stretch;
      justify-content: center;
      margin-bottom: 7px;
      transition: height 0.2s ease, opacity 0.2s ease, margin 0.2s ease;
      will-change: height, opacity;
    }
    
    /* Анимированный фон лирики */
    .lyrics-animated-bg {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      opacity: 0;
      background: linear-gradient(45deg, 
        rgba(232,1,0,0.05), 
        rgba(77,170,255,0.05), 
        rgba(232,1,0,0.05));
      background-size: 400% 400%;
      animation: none;
      z-index: 0;
      pointer-events: none;
    }
    
    .lyrics-animated-bg.active {
      opacity: 0.15;
      animation: lyricsGradient 15s ease infinite;
    }
    
    @keyframes lyricsGradient {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }
    
    #lyrics-window.lyrics-hidden {
      height: 0 !important;
      opacity: 0;
      margin: 0;
      overflow: hidden;
      pointer-events: none;
    }
    
    #lyrics-window.lyrics-normal {
      height: 8.5em;
    }
    
    #lyrics-window.lyrics-expanded {
      height: 15.3em;
    }
    
    .lyrics-scroll {
      position: relative;
      z-index: 1;
    }
    
    .lyrics-window-line {
      opacity: 0.57;
      font-size: 1.13em;
      transition: all 0.2s;
      line-height: 1.7em;
      text-align: center;
      min-height: 1.7em;
      max-width: 97%;
      margin: 0 auto;
      color: #eee;
      white-space: pre-line;
      user-select: none;
      word-break: break-word;
      position: relative;
      z-index: 1;
    }
    
    .lyrics-window-line.active {
      color: var(--primary-color);
      font-weight: bold;
      opacity: 1;
      text-shadow: 0 1px 7px #73161644;
      background: rgba(0,0,0,0.07);
      border-radius: 8px;
      font-size: 1.19em;
    }
         
    /* ==================== АНИМАЦИЯ ЛИРИКИ ИСПРАВЛЕННАЯ ==================== */
    /* Анимированный фон лирики */
    .lyrics-animated-bg {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      opacity: 0;
      background: linear-gradient(45deg, 
        rgba(232,1,0,0.15), 
        rgba(77,170,255,0.15), 
        rgba(232,1,0,0.15));
      background-size: 400% 400%;
      animation: none;
      z-index: 0;
      pointer-events: none;
      transition: opacity 0.5s;
    }

    .lyrics-animated-bg.active {
      opacity: 1;
      animation: lyricsGradient 10s ease infinite;
    }

    @keyframes lyricsGradient {
      0% { 
        background-position: 0% 50%;
        filter: hue-rotate(0deg);
      }
      50% { 
        background-position: 100% 50%;
        filter: hue-rotate(30deg);
      }
      100% { 
        background-position: 0% 50%;
        filter: hue-rotate(0deg);
      }
    }

    /* Убрана анимация transform для текста лирики */
    #lyrics-window.animation-active .lyrics-window-line {
      transition: opacity 0.3s ease;
    }

    #lyrics-window.animation-active .lyrics-window-line.active {
      /* Только эффект свечения, без изменения размера */
      animation: lyricsGlow 2s ease-in-out infinite; /* Увеличена длительность для плавности */
    }

    @keyframes lyricsGlow {
      0%, 100% { 
        opacity: 1;
      }
      50% { 
        opacity: 1;
      }
    }
    /* ==================== КОНЕЦ АНИМАЦИИ ЛИРИКИ ==================== */
    
    .audio-wrapper {
      width: 100%;
      max-width: 395px;
      margin: 0 auto;
    }
    
    /* Скрываем нативный плеер */
    #audio {
      position: absolute;
      width: 1px;
      height: 1px;
      opacity: 0;
      pointer-events: none;
    }
    
    /* Контролы плеера - ОБНОВЛЕНО ДЛЯ 2 РЯДОВ */
    .player-controls {
      display: flex;
      flex-direction: column;
      gap: 5px; /* УМЕНЬШЕНО: было 8px */
      margin: 5px 0; /* УМЕНЬШЕНО: было 10px 0 */
      padding: 8px 10px; /* УМЕНЬШЕНО: было 10px */
      background: rgba(0,0,0,0.3);
      border-radius: 12px;
    }
    
    .player-controls-row {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 12px;
    }
    
    .player-control-btn {
      background: none;
      border: none;
      color: var(--secondary-color);
      cursor: pointer;
      padding: 4px; /* УМЕНЬШЕНО */
      border-radius: 50%;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 32px; /* УМЕНЬШЕНО для второго ряда */
      height: 32px; /* УМЕНЬШЕНО для второго ряда */
      font-weight: bold;
      font-size: 16px; /* УМЕНЬШЕНО */
      position: relative;
    }
    
    /* Кнопки первого ряда - крупнее */
    .player-controls-row:first-child .player-control-btn {
      width: 48px; /* Крупнее для первого ряда */
      height: 48px;
      padding: 8px;
    }
    
    .player-controls-row:first-child .player-control-btn svg {
      width: 28px;
      height: 28px;
    }
    
    /* Кнопки второго ряда - мельче */
    .player-controls-row:last-child .player-control-btn svg {
      width: 20px;
      height: 20px;
    }
    
    .player-controls-row:last-child .player-control-btn {
      font-size: 16px;
    }
    
    .player-control-btn:hover {
      background: rgba(77, 170, 255, 0.2);
      transform: scale(1.1);
    }
    
    .player-control-btn:active {
      transform: scale(0.95);
    }
    
    .player-control-btn.active {
      color: var(--primary-color);
      background: rgba(232, 1, 0, 0.2);
    }
    
    .player-control-btn.repeat-active {
      color: var(--primary-color);
      background: rgba(232, 1, 0, 0.2);
    }
    
    .player-control-btn.favorites-active {
      background: rgba(255, 215, 0, 0.3);
    }
    
    /* Кнопки Animation и Bit */
    .player-control-btn.animation-btn,
    .player-control-btn.bit-btn {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      font-size: 22px;
      font-weight: bold;
    }
    
    .player-control-btn.animation-active,
    .player-control-btn.bit-active {
      color: var(--primary-color);
      background: rgba(232, 1, 0, 0.2);
    }
    
    .player-control-btn svg {
      width: 24px;
      height: 24px;
    }
    
    .player-control-btn.main {
      width: 54px;
      height: 54px;
    }
    
    .player-control-btn.main svg {
      width: 30px;
      height: 30px;
    }
    
    .player-control-btn img {
      width: 22px;
      height: 22px;
      filter: none;
    }
    
    .player-control-btn.favorites-active img {
      filter: drop-shadow(0 0 4px gold);
    }
    
    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.1); }
    }
    
    .player-control-btn.repeat-active svg,
    .player-control-btn.favorites-active img {
      animation: pulse 2s infinite;
    }
    /* ИСПРАВЛЕННЫЙ Прогресс бар для трека */
    .player-progress-wrapper {
      width: 100%;
      margin: 3px 0 5px 0; /* УМЕНЬШЕНО: было 10px 0 */
      position: relative;
    }

    .player-progress-bar {
      width: 100%;
      height: 6px; /* ИСПРАВЛЕНО: было 40px, теперь 6px как у громкости */
      background: rgba(255, 255, 255, 0.1);
      border-radius: 3px; /* ИСПРАВЛЕНО: было 20px */
      position: relative;
      cursor: pointer;
      overflow: visible; /* Изменено для видимости ручки */
    }

    .player-progress-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--primary-color), var(--secondary-color));
      width: 0%;
      transition: width 0.1s linear;
      border-radius: 3px;
      position: relative;
    }

    .player-progress-handle {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      width: 20px;
      height: 20px;
      background: #fff;
      border-radius: 50%;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
      right: -10px;
      z-index: 2;
    }

    /* Таймер времени - УБИРАЕМ ОТДЕЛЬНУЮ СТРОКУ */
    .player-time-display {
      display: none !important; /* Скрываем отдельную строку времени */
    }
    
    /* Время в контролах плеера */
    .time-in-controls {
      font-family: 'SF Mono', Monaco, 'Courier New', monospace;
      font-size: 13px;
      color: var(--secondary-color);
      min-width: 45px;
      text-align: center;
      user-select: none;
    }

        /* Контроллер громкости */
    .volume-control-wrapper {
      width: 100%;
      margin: 5px 0;
      padding: 0 10px;
    }

    .volume-header {
      display: none !important;
    }

    .volume-icon {
      width: 24px;
      height: 24px;
      cursor: pointer;
      opacity: 0.8;
      transition: opacity 0.2s;
    }

    .volume-icon:hover {
      opacity: 1;
    }

    .volume-icon svg {
      width: 100%;
      height: 100%;
      fill: var(--secondary-color);
    }

    .volume-percentage {
      font-size: 12px;
      color: rgba(255, 255, 255, 0.6);
      min-width: 35px;
      text-align: right;
    }

        .volume-slider-container {
      width: 100%;
      height: 20px;
      position: relative;
    }

    .volume-slider {
      -webkit-appearance: none;
      appearance: none;
      width: 100%;
      height: 20px;
      background: transparent;
      outline: none;
      cursor: pointer;
      position: relative;
      z-index: 2;
    }

        .volume-track {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      width: 100%;
      height: 6px;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 3px;
      pointer-events: none;
    }

    .volume-fill {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      height: 6px;
      background: var(--secondary-color);
      border-radius: 3px;
      pointer-events: none;
      transition: width 0.1s;
    }

    .volume-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 20px;
      height: 20px;
      background: #fff;
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
    }

    .volume-slider::-moz-range-thumb {
      width: 20px;
      height: 20px;
      background: #fff;
      border-radius: 50%;
      cursor: pointer;
      border: none;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
    }

    /* Sleep таймер */
    .sleep-timer-btn {
      background: none;
      border: none;
      color: var(--secondary-color);
      cursor: pointer;
      padding: 8px;
      border-radius: 50%;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 44px;
      height: 44px;
      position: relative;
    }

    .sleep-timer-btn:hover {
      background: rgba(77, 170, 255, 0.2);
      transform: scale(1.1);
    }

    .sleep-timer-btn.active {
      color: var(--primary-color);
      background: rgba(232, 1, 0, 0.2);
    }

    .sleep-timer-badge {
      position: absolute;
      top: -2px;
      right: -2px;
      background: var(--primary-color);
      color: white;
      border-radius: 10px;
      padding: 2px 6px;
      font-size: 10px;
      font-weight: bold;
      min-width: 20px;
      text-align: center;
    }

    /* Sleep меню */
    .sleep-menu {
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      background: var(--modal-bg);
      border-radius: 12px;
      padding: 10px;
      margin-bottom: 10px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.3);
      z-index: 100;
      min-width: 150px;
      display: none;
    }

    .sleep-menu.active {
      display: block;
      animation: slideUp 0.2s;
    }

    .sleep-menu-item {
      padding: 8px 12px;
      cursor: pointer;
      border-radius: 6px;
      transition: background 0.2s;
      white-space: nowrap;
      color: var(--text-color);
    }

    .sleep-menu-item:hover {
      background: rgba(255,255,255,0.1);
    }

    .sleep-menu-item.active {
      background: var(--primary-color);
      color: white;
    }

    /* Sleep оверлей */
    .sleep-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.95);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 10000;
    }

    .sleep-overlay.active {
      display: flex;
      animation: fadeIn 0.5s;
    }

    .sleep-content {
      text-align: center;
      padding: 40px;
      max-width: 400px;
    }

    .sleep-icon {
      font-size: 64px;
      margin-bottom: 20px;
      opacity: 0.5;
    }

    .sleep-title {
      font-size: 24px;
      margin-bottom: 10px;
      color: var(--text-color);
    }

    .sleep-message {
      color: rgba(255,255,255,0.6);
      margin-bottom: 30px;
    }

    .sleep-buttons {
      display: flex;
      gap: 10px;
      justify-content: center;
    }

    .sleep-btn {
      padding: 12px 24px;
      border-radius: 8px;
      border: none;
      cursor: pointer;
      font-weight: bold;
      transition: opacity 0.2s;
    }

    .sleep-btn-primary {
      background: var(--primary-color);
      color: white;
    }

    .sleep-btn-secondary {
      background: rgba(255,255,255,0.1);
      color: var(--text-color);
    }

    .sleep-btn:hover {
      opacity: 0.8;
    }

    /* Кнопка управления лирикой */
    .lyrics-toggle-btn {
      position: absolute;
      left: 10px;
      top: 50%;
      transform: translateY(-50%);
      width: 44px;
      height: 44px;
      background: none;
      border: none;
      cursor: pointer;
      padding: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      font-weight: bold;
      transition: all 0.2s ease;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
      z-index: 5;
    }

    /* Визуальная часть кнопки */
    .lyrics-toggle-btn-visual {
      font-size: 36px;
      line-height: 1;
      transition: all 0.2s ease;
      pointer-events: none;
    }

    /* Состояние normal - синяя, большая */
    .lyrics-toggle-btn.lyrics-normal .lyrics-toggle-btn-visual {
      color: var(--secondary-color);
      font-size: 36px;
    }

    /* Состояние hidden - красная, большая */
    .lyrics-toggle-btn.lyrics-hidden .lyrics-toggle-btn-visual {
      color: var(--primary-color);
      font-size: 36px;
    }

    /* Состояние expanded - синяя, маленькая */
    .lyrics-toggle-btn.lyrics-expanded .lyrics-toggle-btn-visual {
      color: var(--secondary-color);
      font-size: 20px;
    }

    /* Hover эффекты */
    .lyrics-toggle-btn:hover .lyrics-toggle-btn-visual {
      transform: scale(1.1);
    }

    .lyrics-toggle-btn:active .lyrics-toggle-btn-visual {
      transform: scale(0.95);
    }

    /* Контейнер для кнопок с позиционированием */
    .player-buttons-wrapper {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 9px;
      margin-top: 10px;
      width: 100%;
      position: relative;
    }
    
    .karaoke-btn, .player-download-btn {
      color: var(--secondary-color) !important;
      background: none;
      border: none;
      cursor: pointer;
      font-size: 1em;
      text-transform: uppercase;
      font-weight: 700;
      letter-spacing: 0.02em;
      text-decoration: underline;
      transition: all 0.18s;
      padding: 4px 16px;
      min-width: 148px;
      text-align: center;
      border-radius: 7px;
      display: block;
      margin: 0 auto;
    }
    
    .karaoke-btn:hover, .player-download-btn:hover {
      color: #fff !important;
      background: #273050;
    }
    
    .bottom-controls-center {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      margin: 32px auto 0 auto;
      gap: 8px;
      width: 100%;
      max-width: 280px;
      padding-bottom: env(safe-area-inset-bottom);
    }
    
    /* ИСПРАВЛЕННАЯ Кнопка фильтра избранных */
    .filter-favorites-btn {
      display: block;
      margin: 0 auto 15px auto;
      padding: 10px 20px;
      background: linear-gradient(135deg, #2a2a2a, #1a1a1a);
      color: var(--secondary-color);
      border: 2px solid var(--border-color);
      border-radius: 12px;
      font-size: 0.95em; /* ИСПРАВЛЕНО: уменьшен размер шрифта */
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s;
      text-align: center;
      min-width: 100%; /* ИСПРАВЛЕНО: растягиваем на всю ширину контейнера */
      white-space: nowrap; /* ИСПРАВЛЕНО: запрещаем перенос */
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
    }
    
    .filter-favorites-btn:hover {
      background: linear-gradient(135deg, #3a3a3a, #2a2a2a);
      border-color: var(--secondary-color);
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.5);
    }
    
    .filter-favorites-btn.filtered {
      background: linear-gradient(135deg, #4a1a1a, #2a0a0a);
      border-color: var(--primary-color);
      color: #fff;
      animation: pulseRed 20s infinite;
    }
    
    @keyframes pulseRed {
      0%, 94.5% { 
        border-color: var(--primary-color);
        box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        background: linear-gradient(135deg, #4a1a1a, #2a0a0a);
      }
      95%, 95.5%, 96%, 96.5%, 97%, 97.5% { 
        border-color: #ff0000;
        box-shadow: 0 0 25px rgba(232,1,0,1);
        transform: scale(1.05);
        background: linear-gradient(135deg, #ff0000, #8a0000);
      }
      95.25%, 95.75%, 96.25%, 96.75%, 97.25%, 97.75% {
        border-color: var(--primary-color);
        box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        transform: scale(1);
        background: linear-gradient(135deg, #4a1a1a, #2a0a0a);
      }
      100% {
        border-color: var(--primary-color);
        box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        background: linear-gradient(135deg, #4a1a1a, #2a0a0a);
      }
    }
    
    /* Сообщение когда нет избранных */
    .no-favorites-message {
      text-align: center;
      padding: 30px;
      color: #888;
      font-size: 1.1em;
      background: rgba(255,255,255,0.05);
      border-radius: 12px;
      margin: 20px;
    }
    
    .no-favorites-message .star-icon {
      font-size: 3em;
      margin-bottom: 10px;
      opacity: 0.5;
    }

    /* Кнопка ГОРЯЧИЕ КЛАВИШИ */
    .hotkeys-btn {
      color: var(--secondary-color) !important;
      text-decoration: underline !important;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.03em;
      cursor: pointer;
      transition: color 0.18s;
      font-size: 1em;
      display: block;
      text-align: center;
      width: 100%;
      margin: 0;
      background: none;
      border: none;
      padding: 8px;
    }
    
    .hotkeys-btn:hover {
      color: #fff !important;
    }

    /* Модальное окно горячих клавиш */
    .hotkeys-modal {
      background: var(--modal-bg);
      border-radius: 14px;
      padding: 24px 20px;
      max-width: 450px;
      max-height: 80vh;
      overflow-y: auto;
      box-shadow: 0 4px 32px #0009;
      position: relative;
      animation: slideUp 0.3s;
    }

    .hotkeys-modal h2 {
      font-size: 1.3em;
      margin-bottom: 20px;
      color: var(--primary-color);
      text-align: center;
    }

    .hotkeys-section {
      margin-bottom: 20px;
    }

    .hotkeys-section h3 {
      color: var(--secondary-color);
      font-size: 1.1em;
      margin-bottom: 10px;
      border-bottom: 1px solid var(--border-color);
      padding-bottom: 5px;
    }

    .hotkey-item {
      display: flex;
      justify-content: space-between;
      padding: 5px 0;
      font-size: 0.95em;
    }

    .hotkey-combo {
      color: #fff;
      background: rgba(255,255,255,0.1);
      padding: 2px 8px;
      border-radius: 4px;
      font-family: 'SF Mono', Monaco, monospace;
      font-weight: bold;
      min-width: 50px;
      text-align: center;
    }

    .hotkey-desc {
      flex: 1;
      margin-left: 15px;
      color: rgba(255,255,255,0.8);
    }
    #install-pwa-btn, #download-album-main {
      color: #fff;
      background: var(--secondary-color);
      border: none;
      border-radius: 7px;
      font-size: 1.07em;
      font-weight: bold;
      letter-spacing: 0.02em;
      margin: 15px 0 5px 0;
      padding: 8px 13px;
      cursor: pointer;
      width: 98%;
      box-shadow: 0 4px 14px #0005;
      outline: none;
      transition: background 0.2s;
    }
    
    #download-album-main {
      background: var(--primary-color);
      font-size: 1.09em;
      margin-bottom: 8px;
    }
    
    #install-pwa-btn:hover { background: #3275c2; }
    #download-album-main:hover { background: #c60000; }
    
    .feedback-link, .support-link {
      color: var(--secondary-color) !important;
      text-decoration: underline !important;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.03em;
      cursor: pointer;
      transition: color 0.18s;
      font-size: 1em;
      display: block;
      text-align: center;
      width: 100%;
      margin: 0;
    }
    
    .feedback-link:hover, .support-link:hover {
      color: #fff !important;
    }
    
    .offline-btn {
      min-width: 102px;
      height: 38px;
      font-size: 1.05em;
      font-weight: bold;
      border: none;
      border-radius: 9px;
      cursor: pointer;
      letter-spacing: 0.07em;
      box-shadow: 0 2px 8px #06000032;
      transition: background 0.2s, color 0.14s;
      display: block;
      margin: 0 auto;
    }
    
    .offline-btn.online { background: var(--primary-color); color: #fff; }
    .offline-btn.offline { background: #27b34c; color: #fff; }
    .offline-btn:active { opacity: 0.91; }
    .offline-btn:disabled { opacity: 0.7; cursor: not-allowed; }
    
    .offline-progress {
      margin-top: 11px;
      width: 100%;
      height: 8px;
      background: #222;
      border-radius: 6px;
      overflow: hidden;
      box-shadow: 0 1px 6px #222b;
    }
    
    .offline-progress-bar {
      height: 100%;
      background: #2fed54;
      transition: width 0.33s;
    }
    
    .offline-desc {
      text-align: center;
      font-size: 0.97em;
      margin-top: 5px;
      opacity: 0.85;
    }
    
    /* Остальные стили для модалок и адаптивности */
    .download-modal-title {
      font-size: 1.12em;
      font-weight: 700;
      margin-bottom: 13px;
      text-align: center;
    }
    
    .checkbox-container {
      display: flex;
      align-items: center;
      margin: 12px 0;
      cursor: pointer;
      user-select: none;
      position: relative;
      padding-left: 32px;
    }
    
    .checkbox-container input {
      position: absolute;
      opacity: 0;
      cursor: pointer;
      height: 0;
      width: 0;
    }
    
    .checkmark {
      position: absolute;
      left: 0;
      top: 50%;
      transform: translateY(-50%);
      height: 20px;
      width: 20px;
      background-color: #2a2a2a;
      border: 2px solid #444;
      border-radius: 4px;
      transition: all 0.2s;
    }
    
    .checkbox-container:hover input ~ .checkmark {
      background-color: #333;
      border-color: #555;
    }
    
    .checkbox-container input:checked ~ .checkmark {
      background-color: var(--primary-color);
      border-color: var(--primary-color);
    }
    
    .checkmark:after {
      content: "";
      position: absolute;
      display: none;
      left: 6px;
      top: 2px;
      width: 5px;
      height: 10px;
      border: solid white;
      border-width: 0 2px 2px 0;
      transform: rotate(45deg);
    }
    
    .checkbox-container input:checked ~ .checkmark:after {
      display: block;
    }
    
    .checkbox-container input:disabled ~ .checkmark {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .progress-bar {
      width: 100%;
      height: 20px;
      background-color: #2a2a2a;
      border-radius: 10px;
      overflow: hidden;
      margin: 20px 0;
    }
    
    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--primary-color), #ff4444);
      transition: width 0.3s ease;
      will-change: width;
    }
    
    .size-info {
      padding: 20px;
      background-color: #1f1f1f;
      border-radius: 8px;
      margin: 15px 0;
      text-align: center;
    }
    
    .modal-buttons {
      display: flex;
      gap: 10px;
      margin-top: 20px;
    }
    
    .btn-secondary, .btn-primary {
      flex: 1;
      padding: 10px;
      border: none;
      border-radius: 7px;
      font-weight: bold;
      cursor: pointer;
      transition: opacity 0.2s;
    }
    
    .btn-secondary {
      background: #444;
      color: #fff;
    }
    
    .btn-primary {
      background: var(--primary-color);
      color: #fff;
    }
    
    .btn-secondary:hover, .btn-primary:hover {
      opacity: 0.8;
    }
    
    /* Тосты для уведомлений */
    .toast {
      position: fixed;
      bottom: 80px;
      left: 50%;
      transform: translateX(-50%) translateY(100px);
      background: #2a2a2a;
      border-radius: 12px;
      padding: 15px 20px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.3);
      z-index: 9999;
      opacity: 0;
      transition: all 0.3s ease;
      max-width: 90%;
      word-wrap: break-word;
      pointer-events: none;
    }
    
    .toast.show {
      transform: translateX(-50%) translateY(0);
      opacity: 1;
    }
    
    .toast-content {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .toast-info { border-left: 4px solid var(--secondary-color); }
    .toast-success { border-left: 4px solid #27b34c; }
    .toast-error { border-left: 4px solid var(--primary-color); }
    .toast-warning { border-left: 4px solid #ff9800; }
    .toast-offline { border-left: 4px solid #666; }
    
    /* iOS инструкция установки */
    .ios-install-prompt {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: #1a1a1a;
      border-top-left-radius: 20px;
      border-top-right-radius: 20px;
      padding: 20px;
      transform: translateY(100%);
      transition: transform 0.3s ease;
      z-index: 10000;
      box-shadow: 0 -4px 20px rgba(0,0,0,0.3);
    }
    
    .ios-install-prompt.show {
      transform: translateY(0);
    }
    
    .ios-prompt-content {
      max-width: 400px;
      margin: 0 auto;
      text-align: center;
    }
    
    .ios-prompt-icon {
      width: 60px;
      height: 60px;
      margin-bottom: 15px;
    }
    
    .ios-share-icon {
      width: 20px;
      height: 20px;
      display: inline-block;
      vertical-align: middle;
      color: #007AFF;
    }
    
    .ios-prompt-close {
      position: absolute;
      top: 10px;
      right: 10px;
      background: none;
      border: none;
      color: #666;
      font-size: 28px;
      cursor: pointer;
    }
    
    .ios-prompt-button {
      background: var(--primary-color);
      color: white;
      border: none;
      padding: 12px 30px;
      border-radius: 25px;
      font-weight: bold;
      margin-top: 20px;
      cursor: pointer;
    }
    
    /* iOS предупреждение о громкости */
    .ios-volume-notice {
      position: fixed;
      bottom: 100px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.9);
      color: white;
      padding: 12px 20px;
      border-radius: 20px;
      font-size: 14px;
      z-index: 1000;
      display: none;
      max-width: 90%;
      text-align: center;
    }
    
    .ios-volume-notice.show {
      display: block;
      animation: slideUp 0.3s;
    }
    
    /* Улучшение textarea */
    .real-textarea {
      width: 100%;
      min-height: 120px;
      padding: 10px;
      border: 1px solid var(--border-color);
      border-radius: 8px;
      background: rgba(255,255,255,0.05);
      color: var(--text-color);
      font-size: 14px;
      resize: vertical;
    }
    
    .fake-textarea {
      padding: 15px;
      border: 1px dashed var(--border-color);
      border-radius: 8px;
      cursor: pointer;
      color: #888;
      transition: all 0.2s;
    }
    
    .fake-textarea:hover {
      border-color: var(--secondary-color);
      color: #aaa;
    }
    
    .err-msg { color: #ff6b6b; margin-top: 10px; }
    .success-msg { color: #27b34c; margin-top: 10px; }

    /* Tooltip для кнопок */
    .tooltip {
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.9);
      color: white;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 11px;
      white-space: nowrap;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s;
      margin-bottom: 5px;
      z-index: 1000;
    }

    .player-control-btn:hover .tooltip {
      opacity: 1;
    }

    /* Адаптивность */
    @media (max-width: 600px) {
      .like-star { width: 16px; height: 16px; }
      .logo-bottom { max-width: 66vw; }
      .player-time-display { font-size: 12px; }
      .volume-control-wrapper { padding: 0 5px; }
      .sleep-menu {
        bottom: auto;
        top: 100%;
        margin-bottom: 0;
        margin-top: 10px;
      }
      .lyrics-toggle-btn {
        width: 48px;
        min-height: 48px;
      }
      .hotkeys-btn {
        display: none !important;
      }
    }
    
    @media (max-width: 420px) {
      .modal-feedback { padding: 13px 3vw; }
    }
    
    /* PWA режим */
    @media (display-mode: standalone) {
      body {
        padding-top: env(safe-area-inset-top);
      }
      
      .bottom-controls-center {
        padding-bottom: calc(env(safe-area-inset-bottom) + 10px);
      }
    }

    /* Убираем подсказки на мобильных */
    @media (hover: none) {
      .tooltip {
        display: none;
      }
    }

    /* ==== Прогресс достижений (Этап 1) ==== */
    .ach-progress-root{
      width:100%;
      max-width:398px;
      margin:12px auto 8px auto;
      padding:10px 12px;
      background: rgba(0,0,0,0.30);
      border: 1px solid var(--border-color);
      border-radius: 12px;
      box-shadow: 0 2px 12px rgba(0,0,0,0.25);
      position: relative;
    }
    .ach-progress-header{
      display:flex;
      justify-content:space-between;
      align-items:center;
      margin-bottom:8px;
    }
    .ach-progress-title{
      font-weight:700;
      letter-spacing: .02em;
      color:#fff;
    }
    .ach-badge-soon{
      font-size:.82em;
      color:#bbb;
      background: #232b38;
      border:1px solid var(--border-color);
      padding:2px 8px;
      border-radius:999px;
    }
    .ach-progress-bars{
      position:relative;
      padding-top:8px;
    }
    .ach-bar{
      position:relative;
      width:100%;
      background: rgba(255,255,255,0.10);
      border-radius:3px;
      overflow:hidden;
    }
    .ach-bar-core{ height:6px; box-shadow: inset 0 0 0 1px rgba(0,0,0,0.05); }
    .ach-bar-all{
      height:3px;
      position:absolute;
      left:0; right:0; top:3px;
      background: rgba(255,255,255,0.12);
      border-radius:2px;
    }
    .ach-bar-fill{
      height:100%;
      width:0%;
      background: linear-gradient(90deg, var(--primary-color), var(--secondary-color));
      transition: width 0.3s ease;
    }
    .ach-bar-labels{
      margin-top:8px;
      display:flex;
      justify-content:space-between;
      font-size:.9em;
      color: rgba(255,255,255,0.8);
    }
/* Соцблок — немного места снизу, чтобы bubble не “лип” */
.socials-under-cover { margin: 14px auto 8px auto; }

/* Подсказка теперь в потоке над полосами */
.ach-hint-bubble{
  position: relative;   /* было absolute */
  right: auto;
  top: auto;
  transform: none;      /* убираем translate */
  background: #1f2533;
  border:1px solid var(--border-color);
  color:#e9f0ff;
  padding:8px 10px;
  border-radius:10px;
  box-shadow:0 4px 20px rgba(0,0,0,0.35);
  font-size:.92em;
  max-width: 100%;
  margin-bottom: 10px;  /* отступ перед заголовком прогресса */
  z-index: 1;           /* на всякий случай */
}

/* На всякий случай фиксируем выравнивание названий треков слева */
.track .track-title { text-align: left; }

.ach-last-earn{ margin-top:8px; display:flex; gap:8px; min-height:0; }
@media (max-width:600px){ .ach-hint-bubble{ font-size:.86em; } }
  </style>
</head>
<body>
  <div id="promocode-block">
    <div class="promo-inner">
      <img class="promo-cover" src="Cover.png" alt="Обложка" draggable="false"/>
      <h2>Вход по промокоду</h2>
      <input id="promo-inp" type="text" placeholder="Введите промокод" autocomplete="off" autofocus disabled />
      <button id="promo-btn" onclick="checkPromo()" disabled>Войти</button>
      <div id="promo-error"></div>
    </div>
  </div>
  
  <div id="main-block" class="hidden">
    <header>
      <div id="cover-wrap">
        <button class="cover-gallery-arrow" id="cover-gallery-arrow-left" title="Назад" aria-label="Предыдущая обложка">
          <svg width="34" height="34" viewBox="0 0 34 34">
            <circle cx="17" cy="17" r="16" fill="#23252e" opacity="0.65"/>
            <polyline points="20,10 13,17 20,24" fill="none" stroke="#fff" stroke-width="2.9" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
        </button>
        <img id="cover" src="Cover.png" alt="Обложка альбома" draggable="false"/>
        <button class="cover-gallery-arrow" id="cover-gallery-arrow-right" title="Вперёд" aria-label="Следующая обложка">
          <svg width="34" height="34" viewBox="0 0 34 34">
            <circle cx="17" cy="17" r="16" fill="#23252e" opacity="0.65"/>
            <polyline points="14,10 21,17 14,24" fill="none" stroke="#fff" stroke-width="2.9" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
        </button>
      </div>
      <div id="social-links" class="socials-under-cover"></div>

      <!-- Прогресс достижений -->
      <div id="ach-progress-root" class="ach-progress-root" aria-live="polite">
        <!-- подсказка сразу под соцблоком -->
        <div class="ach-hint-bubble" id="ach-hint-bubble" role="status">
          ✨ Мы готовим достижения. Слушайте — прогресс уже копится.
        </div>

        <div class="ach-progress-header">
          <span class="ach-progress-title">Прогресс достижений</span>
          <span class="ach-badge-soon" id="ach-badge-soon">в разработке, скоро…</span>
        </div>

        <div class="ach-progress-bars">
          <div class="ach-bar ach-bar-core">
            <div class="ach-bar-fill" id="ach-core-fill" style="width:0%"></div>
          </div>
          <div class="ach-bar ach-bar-all">
            <div class="ach-bar-fill" id="ach-all-fill" style="width:0%"></div>
          </div>
          <div class="ach-bar-labels">
            <span id="ach-core-label">0/15 core</span>
            <span id="ach-all-label">0/34 все</span>
          </div>
        </div>

        <div class="ach-last-earn" id="ach-last-earn" aria-hidden="true"></div>
      </div>
    </header>

  <div class="track-list" id="track-list"></div>
    
    <div class="bottom-controls-center">
      <!-- КНОПКА ФИЛЬТРА НАД ЛОГОТИПОМ -->
      <button class="filter-favorites-btn" id="filter-favorites-btn" onclick="toggleFavoritesFilter()">
        Скрыть не отмеченные ⭐ песни
      </button>
      
      <!-- ЛОГОТИП ПОД КНОПКОЙ -->
      <img class="logo-bottom" id="logo-bottom" src="img/logo.png" alt="Логотип" onclick="handleLogoClick()"/>
      
      <!-- ОСТАЛЬНЫЕ КНОПКИ -->
      <button id="install-pwa-btn" style="display: none;">УСТАНОВИТЬ КАК ПРИЛОЖЕНИЕ</button>
      <button id="download-album-main" onclick="openAlbumDownloadModal()">СКАЧАТЬ ВЕСЬ АЛЬБОМ</button>
      
      <!-- Кнопка ГОРЯЧИЕ КЛАВИШИ - появляется динамически между кнопками -->
      <button class="hotkeys-btn" id="hotkeys-btn" style="display: none;" onclick="showHotkeysModal()">
        ГОРЯЧИЕ КЛАВИШИ
      </button>
      
      <span class="feedback-link" id="feedback-link">ОБРАТНАЯ СВЯЗЬ</span>
      <a class="support-link" id="support-link" href="#" target="_blank">ПОДДЕРЖАТЬ</a>
      <button class="offline-btn online" id="offline-btn" onclick="offlineUIClick()">ONLINE</button>
    </div>
  </div>
  <!-- Модальные окна -->
  <div class="modal-bg" id="modal-feedback">
    <div class="modal-feedback">
      <button class="bigclose" onclick="closeFeedbackModal()" title="Закрыть">
        <svg viewBox="0 0 48 48">
          <line x1="12" y1="12" x2="36" y2="36" stroke="currentColor" stroke-width="6" stroke-linecap="round"/>
          <line x1="36" y1="12" x2="12" y2="36" stroke="currentColor" stroke-width="6" stroke-linecap="round"/>
        </svg>
      </button>
      <div id="feedback-step">
        <div class="fake-textarea" onclick="showRealTextarea()">
          Опишите здесь проблему или своё пожелание для улучшения,<br>можете просто оставить свой отзыв...
        </div>
      </div>
      <div id="modal-feedback-error" class="err-msg"></div>
      <div id="modal-feedback-success" class="success-msg"></div>
      <button onclick="sendFeedbackMsg()" id="send-feedback-btn">Отправить</button>
    </div>
  </div>
  
  <div class="modal-bg" id="modal-offline">
    <div class="modal-feedback" style="max-width:400px;">
      <button class="bigclose" onclick="closeOfflineModal()" title="Закрыть">
        <svg viewBox="0 0 48 48">
          <line x1="12" y1="12" x2="36" y2="36" stroke="currentColor" stroke-width="6" stroke-linecap="round"/>
          <line x1="36" y1="12" x2="12" y2="36" stroke="currentColor" stroke-width="6" stroke-linecap="round"/>
        </svg>
      </button>
      <div id="offline-step"></div>
    </div>
  </div>
  
  <div class="modal-bg" id="install-modal">
    <div class="modal-feedback" style="max-width:400px;">
      <button class="bigclose" onclick="closeInstallModal()" title="Закрыть">
        <svg viewBox="0 0 48 48">
          <line x1="12" y1="12" x2="36" y2="36" stroke="currentColor" stroke-width="6" stroke-linecap="round"/>
          <line x1="36" y1="12" x2="12" y2="36" stroke="currentColor" stroke-width="6" stroke-linecap="round"/>
        </svg>
      </button>
      <div style="font-size:1.18em;font-weight:700;margin-bottom:13px;">
        Установить приложение<br>«Витрина Разбита»?
      </div>
      <div style="margin-bottom:16px;font-size:1em;">
        Приложение будет установлено на ваше устройство, займёт ~1 МБ.<br>
        Его можно будет удалить как обычное приложение.<br>
        Работает даже без интернета.<br><br>
        <b>Для защиты запустим контрольное хэширование ресурсов.</b>
      </div>
      <div id="install-modal-hash" style="font-size:.95em; color:#4daaff; margin-bottom:10px; display:none;">
        Хэширование...<br>
        <span id="install-hash-progress"></span>
      </div>
      <button class="offline-btn online" id="install-proceed-btn" style="width:99%;margin-bottom:7px;">Установить</button>
      <button class="offline-btn" style="width:99%;" onclick="closeInstallModal()">Отмена</button>
    </div>
  </div>
  
  <div class="modal-bg" id="download-modal">
    <div class="modal-feedback" style="max-width:400px;">
      <div class="download-modal-title">Что сделать с этим файлом?</div>
      <div style="margin-bottom:19px;font-size:.98em;" id="download-modal-filename"></div>
      <button class="offline-btn online" style="width:98%;margin-bottom:10px;" onclick="downloadCurrentTrack()">Сохранить на устройство</button>
      <button class="offline-btn" style="width:98%;margin-bottom:10px;" onclick="shareCurrentTrack()">Поделиться с друзьями</button>
      <button class="offline-btn" style="width:98%;margin-bottom:10px;" onclick="openInAppCurrentTrack()">Открыть в приложении</button>
      <button class="offline-btn" style="width:98%;margin-bottom:10px;" onclick="copyLinkCurrentTrack()">Скопировать ссылку</button>
      <button class="offline-btn" style="width:98%;margin-bottom:10px;" onclick="openAlbumDownloadModal()">Скачать весь альбом</button>
      <button class="offline-btn" style="width:98%;" onclick="closeDownloadModal()">Отмена</button>
    </div>
  </div>
  
  <!-- Модальные окна для скачивания альбома -->
  <div class="modal-bg" id="albumDownloadModal">
    <div class="modal-feedback" style="max-width: 400px;">
      <h2 style="text-align: center; margin-bottom: 25px;">Между Злом и Добром</h2>
      
      <div class="download-options">
        <label class="checkbox-container">
          <input type="checkbox" id="includeCovers" checked>
          <span class="checkmark"></span>
          Обложки (галерея)
        </label>
        
        <label class="checkbox-container">
          <input type="checkbox" id="includeLyrics" checked>
          <span class="checkmark"></span>
          Тексты песен
        </label>
        
        <hr style="margin: 15px 0; border-color: #333;">
        
        <label class="checkbox-container">
          <input type="checkbox" id="onlyFavorites">
          <span class="checkmark"></span>
          Только избранные песни
        </label>
        
        <label class="checkbox-container">
          <input type="checkbox" id="fullAlbum" checked>
          <span class="checkmark"></span>
          Полностью альбом
        </label>
      </div>
      
      <div class="modal-buttons">
        <button onclick="closeAlbumDownloadModal()" class="btn-secondary">ОТМЕНА</button>
        <button onclick="prepareDownload()" class="btn-primary">СКАЧАТЬ</button>
      </div>
    </div>
  </div>
  
  <div class="modal-bg" id="sizeConfirmModal">
    <div class="modal-feedback" style="max-width: 350px;">
      <h3 style="text-align: center;">Подтверждение загрузки</h3>
      
      <div class="size-info">
        <div style="font-size: 48px; color: #E80100; margin-bottom: 15px;">📦</div>
        <p style="font-size: 18px; margin: 10px 0;">
          Размер архива: <strong id="archiveSize">0 МБ</strong>
        </p>
        <p style="color: #888; font-size: 14px;">
          Файлов в архиве: <span id="fileCount">0</span>
        </p>
      </div>
      
      <div class="modal-buttons">
        <button onclick="closeSizeConfirmModal()" class="btn-secondary">ОТМЕНА</button>
        <button onclick="startDownload()" class="btn-primary">СКАЧАТЬ</button>
      </div>
    </div>
  </div>
  
  <div class="modal-bg" id="downloadProgressModal">
    <div class="modal-feedback" style="max-width: 400px;">
      <h3 style="text-align: center; margin-bottom: 20px;">Подготовка архива</h3>
      
      <div class="progress-bar">
        <div id="progressFill" class="progress-fill" style="width: 0%"></div>
      </div>
      
      <p id="progressText" style="text-align: center; margin-top: 10px;">
        Загрузка файлов: 0/0
      </p>
      
      <div id="errorsList" style="display: none; color: #ff6b6b; font-size: 14px; margin-top: 15px;">
        <p><strong>Не удалось загрузить:</strong></p>
        <ul id="errorsListContent"></ul>
      </div>
    </div>
  </div>

  <!-- Модальное окно горячих клавиш -->
  <div class="modal-bg" id="hotkeys-modal">
    <div class="hotkeys-modal">
      <button class="bigclose" onclick="closeHotkeysModal()" title="Закрыть">
        <svg viewBox="0 0 48 48">
          <line x1="12" y1="12" x2="36" y2="36" stroke="currentColor" stroke-width="6" stroke-linecap="round"/>
          <line x1="36" y1="12" x2="12" y2="36" stroke="currentColor" stroke-width="6" stroke-linecap="round"/>
        </svg>
      </button>
      
      <h2>📌 ГОРЯЧИЕ КЛАВИШИ</h2>
      
      <div class="hotkeys-section">
        <h3>▶️ Воспроизведение</h3>
        <div class="hotkey-item">
          <span class="hotkey-combo">K / Пробел</span>
          <span class="hotkey-desc">Воспроизведение/Пауза</span>
        </div>
        <div class="hotkey-item">
          <span class="hotkey-combo">X</span>
          <span class="hotkey-desc">Стоп</span>
        </div>
        <div class="hotkey-item">
          <span class="hotkey-combo">N</span>
          <span class="hotkey-desc">Следующий трек</span>
        </div>
        <div class="hotkey-item">
          <span class="hotkey-combo">P</span>
          <span class="hotkey-desc">Предыдущий трек</span>
        </div>
        <div class="hotkey-item">
          <span class="hotkey-combo">J / L</span>
          <span class="hotkey-desc">Перемотка ←10сек / 10сек→</span>
        </div>
        <div class="hotkey-item">
          <span class="hotkey-combo">+ / -</span>
          <span class="hotkey-desc">Громкость ±10%</span>
        </div>
      </div>
      
      <div class="hotkeys-section">
        <h3>🎵 Режимы</h3>
        <div class="hotkey-item">
          <span class="hotkey-combo">R</span>
          <span class="hotkey-desc">Повтор</span>
        </div>
        <div class="hotkey-item">
          <span class="hotkey-combo">U</span>
          <span class="hotkey-desc">Случайный порядок</span>
        </div>
        <div class="hotkey-item">
          <span class="hotkey-combo">F</span>
          <span class="hotkey-desc">Избранные</span>
        </div>
        <div class="hotkey-item">
          <span class="hotkey-combo">M</span>
          <span class="hotkey-desc">Без звука</span>
        </div>
        <div class="hotkey-item">
          <span class="hotkey-combo">T</span>
          <span class="hotkey-desc">Таймер сна</span>
        </div>
      </div>
      
      <div class="hotkeys-section">
        <h3>✨ Эффекты</h3>
        <div class="hotkey-item">
          <span class="hotkey-combo">A</span>
          <span class="hotkey-desc">Анимация лирики</span>
        </div>
        <div class="hotkey-item">
          <span class="hotkey-combo">B</span>
          <span class="hotkey-desc">Пульсация логотипа</span>
        </div>
        <div class="hotkey-item">
          <span class="hotkey-combo">1 / 2 / 3</span>
          <span class="hotkey-desc">Интенсивность (100%/50%/15%)</span>
        </div>
      </div>
      
      <div class="hotkeys-section">
        <h3>📱 Интерфейс</h3>
        <div class="hotkey-item">
          <span class="hotkey-combo">Y</span>
          <span class="hotkey-desc">Показать лирику</span>
        </div>
        <div class="hotkey-item">
          <span class="hotkey-combo">W</span>
          <span class="hotkey-desc">Показать плейлист</span>
        </div>
        <div class="hotkey-item">
          <span class="hotkey-combo">D</span>
          <span class="hotkey-desc">В избранное</span>
        </div>
        <div class="hotkey-item">
          <span class="hotkey-combo">/</span>
          <span class="hotkey-desc">Поиск</span>
        </div>
        <div class="hotkey-item">
          <span class="hotkey-combo">?</span>
          <span class="hotkey-desc">Эта справка</span>
        </div>
        <div class="hotkey-item">
          <span class="hotkey-combo">Esc</span>
          <span class="hotkey-desc">Закрыть окно</span>
        </div>
      </div>
      
      <div class="hotkeys-section">
        <h3>💡 Комбинации</h3>
        <div class="hotkey-item">
          <span class="hotkey-combo">Shift + F</span>
          <span class="hotkey-desc">Фильтр избранных</span>
        </div>
        <div class="hotkey-item">
          <span class="hotkey-combo">Shift + V</span>
          <span class="hotkey-desc">Громкость 50%</span>
        </div>
        <div class="hotkey-item">
          <span class="hotkey-combo">0</span>
          <span class="hotkey-desc">Выключить/включить звук</span>
        </div>
      </div>
    </div>
  </div>

<script>
// ==================== ИНИЦИАЛИЗАЦИЯ ====================
const VERSION = '6.3.1';
const BUILD_DATE = '2025-01-17';
const BUILD_INFO = {
  version: VERSION,
  date: BUILD_DATE,
  author: 'Витрина Разбита',
  repository: 'https://github.com/apel-s-in/vi3na1bita-mezhdu-zlom-i-dobrom'
};

// Логирование версии при загрузке
console.log(`%c🎵 Витрина Разбита PWA v${VERSION}`, 'color: #E80100; font-size: 16px; font-weight: bold;');
console.log(`%cBuild: ${BUILD_DATE}`, 'color: #4daaff; font-size: 12px;');

// ==== Feature flags (Этап 1) ====
const FeatureFlags = {
  achievementsUI: (localStorage.getItem('ff_achievements_ui') ?? '1') === '1',   // показывать панель
  statsCollect:   (localStorage.getItem('ff_stats_collect') ?? '1') === '1',     // тихий сбор статы
  achievementsLogic: (localStorage.getItem('ff_achievements_logic') ?? '0') === '1' // Этап 2+
};

// Кэшированные DOM элементы
const DOM = {};

// Глобальные переменные
let config = null;
let promoPassed = false;
let configLoaded = false;
let coverGalleryArr = ['Cover.png', 'Cover01.png', 'Cover02.png', 'Cover03.png'];
let coverGalleryIdx = 0;
let coverAutoplay = null;
let currentTrack = -1;
let currentLyrics = [];
let autoPlayEnabled = true; // ИСПРАВЛЕНО: по умолчанию true
let offlineMode = false;
let offlineDownloading = false;
let deferredPrompt = null;

// Новые переменные для плеера
let shuffleMode = false;
let shuffledPlaylist = [];
let shuffleIndex = 0;
let repeatMode = false;
let favoritesOnlyMode = false;
let availableTracks = [];
let favoritesFilterActive = false;

// НОВЫЕ переменные для анимаций
let animationEnabled = false;
let bitEnabled = false;
let bitIntensity = 100; // 100, 50 или 15
let audioContext = null;
let analyser = null;
let audioSource = null;
let animationFrame = null;
let hasShownAnimationWarning = false;
let hasShownBitWarning = false;

let downloadOptions = {
  includeCovers: true,
  includeLyrics: true,
  onlyFavorites: false,
  fullAlbum: true
};
let filesToDownload = [];

// ==================== SERVICE WORKER ====================
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('./service-worker.js').then(async reg => {
    console.log('Service Worker registered', reg);
    
    await navigator.serviceWorker.ready;
    syncOfflineState();
    
    reg.addEventListener('updatefound', () => {
      const newWorker = reg.installing;
      newWorker.addEventListener('statechange', () => {
        if (newWorker.state === 'activated') {
          syncOfflineState();
          NotificationSystem.info('Приложение обновлено');
        }
      });
    });
  });
  
  navigator.serviceWorker.addEventListener('message', event => {
    if (event.data.type === 'CACHE_UPDATED') {
      console.log('Cache updated to version:', event.data.version);
    }
    if (event.data.type === 'REQUEST_OFFLINE_STATE') {
      syncOfflineState();
    }
    if (event.data.type === 'CLEAR_ALL_POSITIONS') {
      // НОВОЕ: Очищаем все позиции при обновлении
      PositionManager.clearAll();
    }
  });
}

function syncOfflineState() {
  offlineMode = localStorage.getItem('offlineMode') === '1';
  if (navigator.serviceWorker && navigator.serviceWorker.controller) {
    navigator.serviceWorker.controller.postMessage({
      type: 'SET_OFFLINE_MODE',
      value: offlineMode
    });
  }
}

// ==================== СИСТЕМА УВЕДОМЛЕНИЙ ====================
class NotificationSystem {
  static queue = [];
  static isShowing = false;
  
  static show(message, type = 'info', duration = 3000) {
    this.queue.push({ message, type, duration });
    if (!this.isShowing) {
      this.processQueue();
    }
  }
  
  static async processQueue() {
    if (this.queue.length === 0) {
      this.isShowing = false;
      return;
    }
    
    this.isShowing = true;
    const { message, type, duration } = this.queue.shift();
    
    const toast = document.createElement('div');
    toast.className = `toast toast-${type}`;
    toast.innerHTML = `
      <div class="toast-content">
        ${this.getIcon(type)}
        <span>${message}</span>
      </div>
    `;
    
    document.body.appendChild(toast);
    
    await new Promise(r => setTimeout(r, 50));
    toast.classList.add('show');
    await new Promise(r => setTimeout(r, duration));
    toast.classList.remove('show');
    await new Promise(r => setTimeout(r, 300));
    toast.remove();
    
    this.processQueue();
  }
  
  static getIcon(type) {
    const icons = {
      info: '📢',
      success: '✅',
      error: '❌',
      warning: '⚠️',
      offline: '📡'
    };
    return icons[type] || icons.info;
  }
  
  static info(msg) { this.show(msg, 'info'); }
  static success(msg) { this.show(msg, 'success'); }
  static error(msg) { this.show(msg, 'error', 5000); }
  static warning(msg) { this.show(msg, 'warning', 4000); }
  static offline(msg) { this.show(msg, 'offline'); }
}

// ==== Device hash ====
function getDeviceHash() {
  let h = localStorage.getItem('device_hash');
  if (h) return h;
  const buf = new Uint8Array(16);
  crypto.getRandomValues(buf);
  h = 'dev_' + Array.from(buf).map(b=>b.toString(16).padStart(2,'0')).join('');
  localStorage.setItem('device_hash', h);
  return h;
}

// ==== Stats store (Этап 1+2) ====
const STATS_LS_KEY = 'vr_stats_v1';
const StatsStore = {
  s: null,
  init() {
    try {
      const raw = localStorage.getItem(STATS_LS_KEY);
      if (raw) {
        this.s = JSON.parse(raw);
        if (Array.isArray(this.s.uniqueTracksPlayed)) {
          this.s.uniqueTracksPlayed = Array.from(new Set(this.s.uniqueTracksPlayed));
        }
        // миграции Этап 2
        if (!this.s.achievements) this.s.achievements = {};         // id -> { unlockedAt, tier }
        if (typeof this.s.lastMajorAchAt !== 'number') this.s.lastMajorAchAt = 0;
      } else {
        this.s = this._fresh();
      }
    } catch {
      this.s = this._fresh();
    }
  },
  _fresh() {
    return {
      schema: 2,
      deviceHash: getDeviceHash(),
      createdAt: Date.now(),
      totals: { totalSeconds: 0, totalValidPlays: 0, totalFullPlays: 0 },
      perTrack: Array.from({length: 16}, ()=>({ validPlays:0, fullPlays:0, totalSeconds:0, lastPlayedAt:0 })),
      uniqueTracksPlayed: [],
      byDay: {},            // YYYY-MM-DD -> { valid:n, seconds:s }
      streak: { current: 0, max: 0, lastDay: null },
      likedCount: (JSON.parse(localStorage.getItem('likedTracks')||'[]')||[]).length,
      achievements: {},     // id -> { unlockedAt, tier }
      lastMajorAchAt: 0
    };
  },
  save() {
    const clone = structuredClone(this.s);
    localStorage.setItem(STATS_LS_KEY, JSON.stringify(clone));
  }
};

// ==== Правила валидности ====
function isValidListen(listenedMs, ended) {
  return listenedMs >= 13_000 || ended === true;
}
function isFullListen(listenedMs, durationMs, ended) {
  if (!durationMs) return false;
  return ended === true || listenedMs >= 0.9 * durationMs;
}
function localDayKey(ts) {
  const d = new Date(ts);
  return `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`;
}

// ==== Тихий сбор статы (Этап 1) ====
const Stats = {
  active: FeatureFlags.statsCollect,
  lastStart: null,       // { ts, trackIndex, startPosMs }
  onStart(trackIndex) {
    if (!this.active) return;
    const audio = document.getElementById('audio');
    if (!audio) return;
    this.lastStart = {
      ts: Date.now(),
      trackIndex,
      startPosMs: Math.floor((audio.currentTime||0)*1000)
    };
  },
  onPauseOrStop(opts={ ended:false }) {
    if (!this.active || !this.lastStart) return;
    const audio = document.getElementById('audio');
    if (!audio) return;
    const now = Date.now();
    const durationMs = Math.floor((audio.duration||0)*1000);
    const posMs = opts.ended ? Math.floor(durationMs) : Math.floor((audio.currentTime||0)*1000);
    const listenedMs = Math.max(0, posMs - (this.lastStart.startPosMs||0));
    const valid = isValidListen(listenedMs, opts.ended);
    const full  = isFullListen(listenedMs, durationMs, opts.ended);
    // ВСТАВИТЬ: учёт валидного прослушивания при shuffle
    if (valid && shuffleMode === true) {
      Ach.incShuffleValid();
    }
    
    if (valid || full) {
      const s = StatsStore.s;
      const idx = this.lastStart.trackIndex;
      if (valid) {
        s.totals.totalValidPlays += 1;
        s.totals.totalSeconds += listenedMs/1000;
        if (!s.uniqueTracksPlayed.includes(idx)) s.uniqueTracksPlayed.push(idx);
      }
      if (full) s.totals.totalFullPlays += 1;

      const pt = s.perTrack[idx];
      if (valid) pt.validPlays += 1;
      if (full) pt.fullPlays += 1;
      pt.totalSeconds += listenedMs/1000;
      pt.lastPlayedAt = now;

      if (valid) {
        const key = localDayKey(now);
        s.byDay[key] = s.byDay[key] || { valid:0, seconds:0 };
        s.byDay[key].valid += 1;
        s.byDay[key].seconds += listenedMs/1000;

        if (!s.streak.lastDay) {
          s.streak.current = 1;
        } else if (key !== s.streak.lastDay) {
          const prev = new Date(s.streak.lastDay+'T00:00:00');
          const cur  = new Date(key+'T00:00:00');
          const diff = Math.round((cur - prev)/86400000);
          s.streak.current = (diff === 1) ? (s.streak.current+1) : 1;
        }
        s.streak.lastDay = key;
        s.streak.max = Math.max(s.streak.max, s.streak.current);
      }

      StatsStore.save();
      AchProgress.updateFromStats();
      Ach.evaluateAfterListen({ ts: now });
    }

    if (opts.ended) this.lastStart = null;
  },
  onLikedCountChanged(cnt) {
    if (!this.active) return;
    StatsStore.s.likedCount = cnt;
    StatsStore.save();
  }
};
// ==== Реестр ачивок (Этап 2) ====
const ACH_META = {
  // Tier 1
  play_first:{tier:1, core:true,  title:'Первое знакомство'},
  unique_5_tracks:{tier:1, core:true, title:'Разный вкус'},
  fav_3:{tier:1, core:false, title:'Первые любимчики'},
  early_bird:{tier:1, core:false, title:'Ранняя пташка'},
  night_listener:{tier:1, core:false, title:'Ночной слушатель'},
  backup_first:{tier:1, core:true, title:'Бережёного бережёт'},

  // Tier 2
  time_listened_1h:{tier:2, core:true, title:'Час в наушниках'},
  play_25_total:{tier:2, core:true, title:'На повторе'},
  full_play_first:{tier:2, core:true, title:'До последней ноты'},
  streak_3:{tier:2, core:true, title:'3 дня подряд'},
  fav_5:{tier:2, core:true, title:'Мой плейлист'},
  use_shuffle_5:{tier:2, core:false, title:'В случайном порядке'},

  // Tier 3
  unique_10_tracks:{tier:3, core:true, title:'Половина альбома'},
  full_10_total:{tier:3, core:true, title:'Верное ухо'},
  streak_7:{tier:3, core:true, title:'Недельный стрик'},
  favorites_order_5_full:{tier:3, core:true, title:'Только избранное — по порядку'},
  favorites_shuffle_5_full:{tier:3, core:true, title:'Только избранное — вперемешку'},
  weekend_warrior:{tier:3, core:false, title:'Выходные с музыкой'},

  // Tier 4
  album_any_order_7d:{tier:4, core:true, title:'Весь альбом'},
  album_in_order_session:{tier:4, core:true, title:'От первой до последней'},
  time_listened_5h:{tier:4, core:false, title:'5 часов музыки'},
  play_100_total:{tier:4, core:false, title:'В потоке'},
  fav_8:{tier:4, core:false, title:'Коллекционер'},
  socials_all_visited:{tier:4, core:false, title:'Подписчик всего'},
  sleep_timer_5:{tier:4, core:false, title:'Бережный сон'},
  pwa_installed:{tier:4, core:false, title:'На моём устройстве'},

  // Tier 5
  full_50_total:{tier:5, core:false, title:'Уважение к деталям'},
  play_500_total:{tier:5, core:false, title:'Полтысячи'},
  one_track_full_25:{tier:5, core:false, title:'Любимейший'},
  one_track_full_100:{tier:5, core:false, title:'Абсолютный фаворит'},
  streak_14:{tier:5, core:false, title:'Две недели подряд'},
  streak_30:{tier:5, core:false, title:'Месяц без пропусков'},

  // Tier 6 (секретные)
  exact_time_11_11:{tier:6, core:false, hidden:true, title:'11:11'},
  midnight_triple:{tier:6, core:false, hidden:true, title:'Полночный цикл'},
  weekend_album:{tier:6, core:false, hidden:true, title:'Выходной марафон'},

  // Backup
  backup_3_days:{tier:4, core:false, title:'Запасливый'},
  backup_after_major:{tier:4, core:false, title:'Сохранил после прогресса'}
};

// ==== Движок ачивок (Этап 2) ====
const Ach = {
  has(id){ return !!StatsStore.s.achievements[id]; },
  unlock(id){
    if (this.has(id)) return false;
    const meta = ACH_META[id]||{};
    StatsStore.s.achievements[id] = { unlockedAt: Date.now(), tier: meta.tier||0 };
    // если Tier >=3 — отметим “major”
    if ((meta.tier||0) >= 3) StatsStore.s.lastMajorAchAt = Date.now();
    StatsStore.save();
    // тост
    NotificationSystem.success(`🏆 Достижение: ${meta.title||id}`);
    // обновим шкалы и подсказку
    AchProgress.updateFromStats();
    return true;
  },
  // Быстрая выдача “событийных”
  event(id){ this.unlock(id); },

  // Проверка “простых” порогов после каждого прослушивания
  evaluateAfterListen({ts}){
    const S = StatsStore.s;
    const uniq = (S.uniqueTracksPlayed||[]).length;
    const tot = S.totals || {};
    const liked = S.likedCount || 0;

    // Tier 1
    if (tot.totalValidPlays >= 1) this.unlock('play_first');
    if (uniq >= 5) this.unlock('unique_5_tracks');
    if (liked >= 3) this.unlock('fav_3');

    // ранние/ночные окна — считаем по времени валидного прослушивания
    const d = new Date(ts);
    const t = d.toTimeString().slice(0,8);
    if (t >= '05:00:00' && t <= '07:00:00') this.unlock('early_bird');
    if (t >= '02:00:00' && t <= '04:30:00') this.unlock('night_listener');

    // Tier 2
    if (tot.totalSeconds >= 3600) this.unlock('time_listened_1h');
    if (tot.totalValidPlays >= 25) this.unlock('play_25_total');
    if (tot.totalFullPlays >= 1) this.unlock('full_play_first');
    if ((StatsStore.s.streak?.max||0) >= 3) this.unlock('streak_3');
    if (liked >= 5) this.unlock('fav_5');
    if ((S._shuffleValid||0) >= 5) this.unlock('use_shuffle_5');

    // Tier 3
    if (uniq >= 10) this.unlock('unique_10_tracks');
    if (tot.totalFullPlays >= 10) this.unlock('full_10_total');
    if ((StatsStore.s.streak?.max||0) >= 7) this.unlock('streak_7');

    // Tier 4
    if (tot.totalSeconds >= 18_000) this.unlock('time_listened_5h');
    if (tot.totalValidPlays >= 100) this.unlock('play_100_total');
    if (liked >= 8) this.unlock('fav_8');

    // Tier 5
    if (tot.totalFullPlays >= 50) this.unlock('full_50_total');
    if (tot.totalValidPlays >= 500) this.unlock('play_500_total');

    // one_track_full_25/100 — проверим пер‑трек
    const pt = StatsStore.s.perTrack || [];
    for (let i=0;i<pt.length;i++){
      const f = pt[i]?.fullPlays||0;
      if (f >= 25) this.unlock('one_track_full_25');
      if (f >= 100) this.unlock('one_track_full_100');
    }

    // ВНИМАНИЕ: сложные ачивки (favorites_order_5_full, favorites_shuffle_5_full,
    // album_in_order_session) подключим на Этапе 3 (SessionManager).
    // album_any_order_7d, weekend_warrior, weekend_album — запланированы на Этап 3 (окна/недели).
  },

  evaluateFromLikes(){
    const liked = StatsStore.s.likedCount || 0;
    if (liked >= 3) this.unlock('fav_3');
    if (liked >= 5) this.unlock('fav_5');
    if (liked >= 8) this.unlock('fav_8');
  },

  // учёт shuffle-валидных прослушиваний (для use_shuffle_5)
  incShuffleValid(){
    StatsStore.s._shuffleValid = (StatsStore.s._shuffleValid||0)+1;
    StatsStore.save();
  }
};
  
// ==== Прогресс‑панель (Этап 1: проценты и подсказка) ====
const AchProgress = {
  coreTotal: 15,        // фиксировано
  visibleTotal: 34,     // все кроме 3 secret
  init() {
    if (!FeatureFlags.achievementsUI) return;
    this.coreFill  = document.getElementById('ach-core-fill');
    this.allFill   = document.getElementById('ach-all-fill');
    this.coreLabel = document.getElementById('ach-core-label');
    this.allLabel  = document.getElementById('ach-all-label');
    this.bubble    = document.getElementById('ach-hint-bubble');
    this.set(0,0);
    this.updateFromStats();
  },
  set(coreUnlocked, visibleUnlocked) {
    const corePct = Math.max(0, Math.min(100, Math.round(coreUnlocked/this.coreTotal*100)));
    const allPct  = Math.max(0, Math.min(100, Math.round(visibleUnlocked/this.visibleTotal*100)));
    if (this.coreFill)  this.coreFill.style.width = corePct + '%';
    if (this.allFill)   this.allFill.style.width  = allPct + '%';
    if (this.coreLabel) this.coreLabel.textContent = `${coreUnlocked}/${this.coreTotal} core`;
    if (this.allLabel)  this.allLabel.textContent  = `${visibleUnlocked}/${this.visibleTotal} все`;
  },
  updateFromStats() {
    const ach = StatsStore.s.achievements || {};
    let coreUnlocked = 0, visibleUnlocked = 0;
    Object.keys(ach).forEach(id=>{
      const meta = ACH_META[id]||{};
      if (meta.core) coreUnlocked++;
      if (!meta.hidden) visibleUnlocked++;
    });
    this.set(coreUnlocked, visibleUnlocked);
    this.updateBubble();
  },
  updateBubble() {
    if (!this.bubble) return;
    const hint = this.computeNearestGoal();
    this.bubble.textContent = hint || '✨ Продолжайте слушать — прогресс идёт.';
  },
  computeNearestGoal() {
    const S = StatsStore.s, T = S.totals||{};
    const uniq = (S.uniqueTracksPlayed||[]).length;
    const liked = S.likedCount||0;
    const streak = S.streak?.current||0;

    const list = [];
    const push = (id, need, have, unit, title) => {
      if (Ach.has(id)) return;
      const left = Math.max(0, need - have);
      const pct = Math.max(0, Math.min(100, Math.round((have/need)*100)));
      list.push({ id, left, pct, unit, title });
    };

    push('play_25_total', 25, T.totalValidPlays||0, 'прослушиваний', ACH_META.play_25_total.title);
    push('time_listened_1h', 3600, Math.floor(T.totalSeconds||0), 'секунд', ACH_META.time_listened_1h.title);
    if (uniq < 10) push('unique_10_tracks', 10, uniq, 'трека', ACH_META.unique_10_tracks.title);
    push('full_10_total', 10, T.totalFullPlays||0, 'полных', ACH_META.full_10_total.title);
    if (streak < 7) push('streak_7', 7, streak, 'дней подряд', ACH_META.streak_7.title);
    if (liked < 5) push('fav_5', 5, liked, 'треков в избранном', ACH_META.fav_5.title);
    push('play_100_total', 100, T.totalValidPlays||0, 'прослушиваний', ACH_META.play_100_total.title);
    push('time_listened_5h', 18000, Math.floor(T.totalSeconds||0), 'секунд', ACH_META.time_listened_5h.title);

    if (!list.length) return null;
    list.sort((a,b)=> (a.left - b.left) || (b.pct - a.pct));
    const best = list[0];
    if (!best) return null;

    const units = (u, n) => (u === 'секунд')
      ? (n >= 60 ? `${Math.ceil(n/60)} мин` : `${n} сек`)
      : `${n} ${u}`;

    return `✨ До «${best.title}»: ${units(best.unit, best.left)}`;
  }
}; // ← закрываем объект AchProgress полностью

// ==================== СОХРАНЕНИЕ СОСТОЯНИЯ ====================
class PlayerState {
  static save() {
    const audio = document.getElementById('audio');
    const state = {
      trackIndex: currentTrack,
      position: audio ? audio.currentTime : 0,
      volume: audio ? audio.volume : 1,
      savedVolume: localStorage.getItem('playerVolume'),
      liked: getLiked(),
      timestamp: Date.now()
    };
    localStorage.setItem('playerState', JSON.stringify(state));
  }
  
  static restore() {
    try {
      const saved = localStorage.getItem('playerState');
      if (!saved) return null;
      
      const state = JSON.parse(saved);
      if (Date.now() - state.timestamp > 24 * 60 * 60 * 1000) {
        return null;
      }
      return state;
    } catch (e) {
      return null;
    }
  }
  
  static apply(state) {
    if (!state || !config) return;
    
    if (state.savedVolume) {
      localStorage.setItem('playerVolume', state.savedVolume);
    }
    
    if (state.trackIndex >= 0 && state.trackIndex < config.tracks.length) {
      showTrack(state.trackIndex, false);
      
      setTimeout(() => {
        const audio = document.getElementById('audio');
        if (audio && state.position > 0) {
          audio.currentTime = state.position;
          audio.volume = state.volume || 1;
        }
      }, 500);
    }
  }
}

// Автосохранение
setInterval(() => {
  const audio = document.getElementById('audio');
  if (audio && !audio.paused) {
    PlayerState.save();
  }
}, 5000);

window.addEventListener('beforeunload', () => {
  PlayerState.save();
});

// ==================== НОВЫЙ КЛАСС УПРАВЛЕНИЯ ПОЗИЦИЯМИ ====================
class PositionManager {
  static save(trackId, position) {
    // Сохраняем позицию ТОЛЬКО текущего трека
    localStorage.setItem('current_track_position', JSON.stringify({
      trackId,
      position,
      timestamp: Date.now()
    }));
  }
  
  static get(trackId) {
    const saved = localStorage.getItem('current_track_position');
    if (!saved) return null;
    
    try {
      const data = JSON.parse(saved);
      
      // Проверяем, что это тот же трек
      if (data.trackId !== trackId) {
        return null;
      }
      
      // Проверяем TTL (1 час = 3600000 мс)
      const age = Date.now() - data.timestamp;
      if (age > 3600000) {
        localStorage.removeItem('current_track_position');
        return null;
      }
      
      return data.position;
    } catch (e) {
      return null;
    }
  }
  
  static clear() {
    localStorage.removeItem('current_track_position');
  }
  
  static clearAll() {
    // Очищаем все старые позиции (для обратной совместимости)
    const keys = Object.keys(localStorage);
    keys.forEach(key => {
      if (key.startsWith('position_') || key === 'current_track_position') {
        localStorage.removeItem(key);
      }
    });
  }
}

// ==================== ЗАГРУЗКА КОНФИГУРАЦИИ ====================
fetch('./config.json')
  .then(r => r.json())
  .then(data => {
    config = data;
    configLoaded = true;
    document.getElementById('promo-inp').disabled = false;
    document.getElementById('promo-btn').disabled = false;
    
    if (localStorage.getItem('promoPassed') === '1') {
      promoPassed = true;
      document.getElementById('main-block').classList.remove('hidden');
      document.getElementById('promocode-block').classList.add('hidden');
      initializeMainUi();
      
      const savedState = PlayerState.restore();
      if (savedState) {
        PlayerState.apply(savedState);
      }
      
      parseDeepLink();
    }
  })
  .catch(err => {
    console.error('Failed to load config:', err);
    NotificationSystem.error('Ошибка загрузки конфигурации');
  });

// ==================== ПРОМОКОД ====================
function checkPromo() {
  const val = document.getElementById('promo-inp').value.trim();
  if (!configLoaded) {
    document.getElementById('promo-error').innerText = "Загрузка данных... Попробуйте через пару секунд.";
    return;
  }
  if (val && config && val.toUpperCase() === config.promoCode.toUpperCase()) {
    promoPassed = true;
    localStorage.setItem('promoPassed', '1');
    document.getElementById('main-block').classList.remove('hidden');
    document.getElementById('promocode-block').classList.add('hidden');
    initializeMainUi();
    setOfflineUIState(offlineMode ? 'offline' : 'online');
    autoPlayEnabled = true; // ИСПРАВЛЕНО: включаем автовоспроизведение после промокода
  } else {
    document.getElementById('promo-error').innerText = "Неверный промокод. Попробуйте ещё!";
  }
}

document.getElementById('promo-inp').addEventListener('keydown', function(e) {
  if (e.key === "Enter") checkPromo();
});

// ==================== ИНИЦИАЛИЗАЦИЯ UI ====================  
function initializeMainUi() {
  DOM.cover = document.getElementById('cover');
  DOM.trackList = document.getElementById('track-list');
  DOM.socialLinks = document.getElementById('social-links');
  
  setCoverImage(coverGalleryIdx);
  buildSocials();
  // ==== Этап 1: старт статы и прогресс‑панели ====
  StatsStore.init();
  AchProgress.init();

  document.getElementById('support-link').href = config.donateLink;
  
  if (config.background) {
    document.body.style.background = `url(${config.background}) center/cover fixed #111`;
  }
  
  buildTrackList();
  updateAvailableTracks();
  
  // НОВОЕ: Проверяем наличие клавиатуры и показываем кнопку горячих клавиш
  if (hasKeyboard()) {
    insertHotkeysButton();
  }
  
  // Восстанавливаем состояние анимаций
  restoreAnimationStates();
  
  document.getElementById('feedback-link').onclick = openFeedbackModal;
  document.getElementById('modal-feedback').onclick = function(e) {
    if (e.target === this) closeFeedbackModal();
  };
  
  document.getElementById('cover-gallery-arrow-left').onclick = function() {
    setCoverImage(coverGalleryIdx - 1);
    startCoverAutoPlay();
  };
  
  document.getElementById('cover-gallery-arrow-right').onclick = function() {
    setCoverImage(coverGalleryIdx + 1);
    startCoverAutoPlay();
  };
  
  let startX = null;
  const el = document.getElementById('cover-wrap');
  
  el.addEventListener('touchstart', function(e) {
    startX = e.touches[0].clientX;
  });
  
  el.addEventListener('touchend', function(e) {
    if (startX === null) return;
    const dx = e.changedTouches[0].clientX - startX;
    if (Math.abs(dx) > 30) {
      if (dx > 0) {
        setCoverImage(coverGalleryIdx - 1);
      } else {
        setCoverImage(coverGalleryIdx + 1);
      }
      startCoverAutoPlay();
    }
    startX = null;
  });
  
  startCoverAutoPlay();
  initializeAlbumDownloadCheckboxes();
  detectIOSAndShowInstallGuide();
  setOfflineUIState(offlineMode ? 'offline' : 'online');
  
  // Восстанавливаем режим отображения лирики
  restoreLyricsViewMode();
  
  // Восстанавливаем фильтр избранных если был активен
  if (localStorage.getItem('favoritesFilter') === '1') {
    const liked = getLiked();
    if (liked.length > 0) {
      favoritesFilterActive = false;
      setTimeout(() => {
        toggleFavoritesFilter();
      }, 500);
    }
  }
  
  // Добавляем слушатель событий для проверки sleep таймера при изменении видимости
  document.addEventListener('visibilitychange', () => {
    if (!document.hidden) {
      checkSleepTimer();
    }
  });
  
  window.addEventListener('focus', checkSleepTimer);
}

// ==================== НОВЫЕ ФУНКЦИИ ДЛЯ АНИМАЦИЙ ====================

// Определение наличия клавиатуры
function hasKeyboard() {
  const isDesktop = !/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
  const hasPointer = window.matchMedia('(pointer: fine)').matches;
  const canHover = window.matchMedia('(hover: hover)').matches;
  const noTouch = navigator.maxTouchPoints === 0;
  
  return (isDesktop && hasPointer) || (canHover && noTouch);
}

// Вставка кнопки горячих клавиш
function insertHotkeysButton() {
  const feedbackLink = document.getElementById('feedback-link');
  const downloadBtn = document.getElementById('download-album-main');
  
  if (feedbackLink && downloadBtn) {
    const hotkeysBtn = document.getElementById('hotkeys-btn');
    if (hotkeysBtn) {
      hotkeysBtn.style.display = 'block';
      // Вставляем между кнопкой скачивания и ссылкой обратной связи
      downloadBtn.parentNode.insertBefore(hotkeysBtn, feedbackLink);
    }
  }
}

// Показать модальное окно горячих клавиш
function showHotkeysModal() {
  document.getElementById('hotkeys-modal').classList.add('active');
}

function closeHotkeysModal() {
  document.getElementById('hotkeys-modal').classList.remove('active');
}

// Обработчик клика по логотипу
function handleLogoClick() {
  if (!bitEnabled) return;
  
  // Циклически меняем интенсивность
  if (bitIntensity === 100) {
    bitIntensity = 50;
  } else if (bitIntensity === 50) {
    bitIntensity = 15;
  } else {
    bitIntensity = 100;
  }
  
  localStorage.setItem('bitIntensity', bitIntensity.toString());
  NotificationSystem.info(`💿 Интенсивность пульсации: ${bitIntensity}%`);
}

// Восстановление состояния анимаций
function restoreAnimationStates() {
  // Восстанавливаем состояние анимации лирики
  const savedAnimation = localStorage.getItem('animationEnabled');
  if (savedAnimation === '1') {
    animationEnabled = true;
  }
  
  // Восстанавливаем состояние пульсации
  const savedBit = localStorage.getItem('bitEnabled');
  if (savedBit === '1') {
    bitEnabled = true;
  }
  
  // Восстанавливаем интенсивность
  const savedIntensity = localStorage.getItem('bitIntensity');
  if (savedIntensity) {
    bitIntensity = parseInt(savedIntensity);
  }
}
// ==================== ФУНКЦИИ АНИМАЦИИ ====================

// Переключение анимации лирики
function toggleAnimation() {
  animationEnabled = !animationEnabled;
  
  const btn = document.getElementById('animation-btn');
  const animBg = document.querySelector('.lyrics-animated-bg');
  const lyricsWindow = document.getElementById('lyrics-window');
  
  if (animationEnabled) {
    // Показываем предупреждение при первом включении
    if (!hasShownAnimationWarning) {
      hasShownAnimationWarning = true;
      localStorage.setItem('hasShownAnimationWarning', '1');
      
      if (confirm('Режим анимации фона лирики увеличивает расход батареи. Продолжить?')) {
        // Продолжаем включение
      } else {
        animationEnabled = false;
        return;
      }
    }
    
    if (btn) btn.classList.add('animation-active');
    if (animBg) animBg.classList.add('active');
    if (lyricsWindow) lyricsWindow.classList.add('animation-active');
    NotificationSystem.success('✨ Анимация лирики включена');
  } else {
    if (btn) btn.classList.remove('animation-active');
    if (animBg) animBg.classList.remove('active');
    if (lyricsWindow) lyricsWindow.classList.remove('animation-active');
    NotificationSystem.info('Анимация лирики выключена');
  }
  
  localStorage.setItem('animationEnabled', animationEnabled ? '1' : '0');
}

// Переключение пульсации логотипа
function toggleBit() {
  bitEnabled = !bitEnabled;
  
  const btn = document.getElementById('bit-btn');
  const logo = document.getElementById('logo-bottom');
  
  if (bitEnabled) {
    // Показываем предупреждение при первом включении
    if (!hasShownBitWarning) {
      hasShownBitWarning = true;
      localStorage.setItem('hasShownBitWarning', '1');
      
      if (confirm('Режим пульсации увеличивает расход батареи. Продолжить?')) {
        // Продолжаем включение
      } else {
        bitEnabled = false;
        return;
      }
    }
    
    if (btn) btn.classList.add('bit-active');
    
    // ИСПРАВЛЕНО: Безопасная инициализация
    try {
      initAudioContext();
      startLogoPulsation();
      NotificationSystem.success('🎵 Пульсация логотипа включена');
    } catch (e) {
      console.error('Ошибка инициализации пульсации:', e);
      bitEnabled = false;
      if (btn) btn.classList.remove('bit-active');
      NotificationSystem.error('Не удалось включить пульсацию');
    }
  } else {
    if (btn) btn.classList.remove('bit-active');
    stopLogoPulsation();
    
    // ИСПРАВЛЕНО: Полная очистка контекста
    if (audioContext) {
      try {
        audioContext.close();
      } catch (e) {
        console.error('Ошибка закрытия контекста:', e);
      }
      audioContext = null;
      audioSource = null;
      analyser = null;
    }
    
    NotificationSystem.info('Пульсация логотипа выключена');
  }
  
  localStorage.setItem('bitEnabled', bitEnabled ? '1' : '0');
}

// Инициализация Web Audio API
function initAudioContext() {
  try {
    // ИСПРАВЛЕНО: Проверяем и закрываем старый контекст безопасно
    if (audioContext) {
      try {
        if (audioContext.state !== 'closed') {
          audioContext.close();
        }
      } catch (e) {
        console.warn('Не удалось закрыть старый контекст:', e);
      }
      audioContext = null;
      audioSource = null;
      analyser = null;
    }
    
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    audioContext = new AudioContext();
    
    analyser = audioContext.createAnalyser();
    analyser.fftSize = 256;
    analyser.smoothingTimeConstant = 0.8;
    
    const audio = document.getElementById('audio');
    if (!audio) {
      console.warn('Audio элемент не найден');
      return;
    }
    
    // ИСПРАВЛЕНО: Проверяем, не был ли уже создан источник для этого элемента
    try {
      // Пытаемся создать новый источник
      audioSource = audioContext.createMediaElementSource(audio);
      audioSource.connect(analyser);
      analyser.connect(audioContext.destination);
    } catch (e) {
      // Если источник уже был создан ранее, пересоздаём плеер
      console.warn('Источник уже существует, пересоздаём подключение');
      
      // Сохраняем состояние
      const currentTime = audio.currentTime;
      const paused = audio.paused;
      const volume = audio.volume;
      const src = audio.src;
      
      // Пересоздаём audio элемент
      const newAudio = audio.cloneNode(false);
      newAudio.src = src;
      newAudio.currentTime = currentTime;
      newAudio.volume = volume;
      
      // Заменяем элемент
      audio.parentNode.replaceChild(newAudio, audio);
      
      // Создаём источник для нового элемента
      audioSource = audioContext.createMediaElementSource(newAudio);
      audioSource.connect(analyser);
      analyser.connect(audioContext.destination);
      
      // Восстанавливаем воспроизведение если нужно
      if (!paused) {
        newAudio.play().catch(err => console.log('Автовоспроизведение заблокировано'));
      }
      // ВСТАВЛЕНО: перепривязать обработчики к новому элементу
      reattachAudioEventListeners(newAudio);
    } // ← закрываем внутренний catch(e)
    // Возобновляем контекст если он был приостановлен
    if (audioContext.state === 'suspended') {
      audioContext.resume();
    }
    
  } catch (e) {
    console.error('Web Audio API не поддерживается:', e);
    
    // Очищаем всё при ошибке
    if (audioContext) {
      try {
        audioContext.close();
      } catch (closeError) {
        console.error('Ошибка закрытия контекста:', closeError);
      }
    }
    
    audioContext = null;
    audioSource = null;
    analyser = null;
    
    throw e; // Пробрасываем ошибку дальше
  }
}
// Функция для переподключения обработчиков событий к новому audio элементу
function reattachAudioEventListeners(audioEl) {
  if (!audioEl) return;

  audioEl.addEventListener('loadedmetadata', onAudioMetadataLoaded);
  audioEl.addEventListener('timeupdate', onAudioTimeUpdate);
  audioEl.addEventListener('seeking', onAudioSeeking);
  audioEl.addEventListener('seeked', onAudioSeeked);
  audioEl.addEventListener('ended', onAudioEnded);
  audioEl.addEventListener('volumechange', onVolumeChange);

  // НУЖНО: play + учёт старта
  audioEl.addEventListener('play', () => {
  if (bitEnabled && audioContext && audioContext.state === 'suspended') {
    audioContext.resume();
  }
  Stats.onStart(currentTrack);
  updatePlayPauseIcon();
});

  // ОДИН обработчик pause
  audioEl.addEventListener('pause', () => {
    Stats.onPauseOrStop({ ended: false });
    updatePlayPauseIcon();
  });

  audioEl.addEventListener('canplay', () => {
    if (bitEnabled && !analyser) {
      initAudioContext();
      startLogoPulsation();
    }
  });
}

// Запуск пульсации логотипа
function startLogoPulsation() {
  if (!bitEnabled || !analyser) return;
  
  const logo = document.getElementById('logo-bottom');
  if (!logo) return;
  
  // Добавляем класс для изоляции
  logo.classList.add('logo-pulsing');
  
  const bufferLength = analyser.frequencyBinCount;
  const dataArray = new Uint8Array(bufferLength);
  
  // Сохраняем ссылку для оптимизации
  let lastScale = 1;
  
  function animate() {
    if (!bitEnabled) {
      if (lastScale !== 1) {
        logo.style.transform = 'scale3d(1, 1, 1)';
        lastScale = 1;
      }
      return;
    }
    
    animationFrame = requestAnimationFrame(animate);
    
    analyser.getByteFrequencyData(dataArray);
    
    // Анализируем низкие частоты (басы)
    let bass = 0;
    for (let i = 0; i < 8; i++) {
      bass += dataArray[i];
    }
    bass = bass / 8;
    
    // Анализируем средние частоты
    let mid = 0;
    for (let i = 8; i < 32; i++) {
      mid += dataArray[i];
    }
    mid = mid / 24;
    
    // Комбинируем для общей пульсации
    const amplitude = (bass * 0.7 + mid * 0.3) / 255;
    
    // Применяем интенсивность
    const scaledAmplitude = amplitude * (bitIntensity / 100);
    
    // Масштабируем логотип (от 1 до 1.3 при 100% интенсивности)
    const scale = 1 + (scaledAmplitude * 0.3);
    
    // Обновляем только если изменилось значительно (оптимизация)
    if (Math.abs(scale - lastScale) > 0.01) {
      logo.style.transform = `scale3d(${scale}, ${scale}, 1)`;
      lastScale = scale;
    }
  }
  
  animate();
}

// Остановка пульсации логотипа
function stopLogoPulsation() {
  const logo = document.getElementById('logo-bottom');
  if (logo) {
    logo.classList.remove('logo-pulsing');
    logo.style.transform = 'scale(1)';
  }
  
  if (animationFrame) {
    cancelAnimationFrame(animationFrame);
    animationFrame = null;
  }
  
  // ИСПРАВЛЕНО: НЕ закрываем контекст здесь, только при полном отключении
}
  
// ==================== ГАЛЕРЕЯ ОБЛОЖЕК ====================
function setCoverImage(idx) {
  coverGalleryIdx = (idx + coverGalleryArr.length) % coverGalleryArr.length;
  if (DOM.cover) {
    DOM.cover.src = coverGalleryArr[coverGalleryIdx];
  }
}

function startCoverAutoPlay() {
  if (coverAutoplay) clearInterval(coverAutoplay);
  coverAutoplay = setInterval(function() {
    setCoverImage(coverGalleryIdx + 1);
  }, 5000);
}

// ==================== СОЦИАЛЬНЫЕ СЕТИ ====================
function buildSocials() {
  if (!config || !config.socials) return;
  const links = config.socials.map(x => 
    `<a href="${x.url}" target="_blank" rel="noopener">${x.title}</a>`
  ).join(" ");
  if (DOM.socialLinks) {
    DOM.socialLinks.innerHTML = links;
  }
}

// ==================== ИЗБРАННОЕ ====================
function getLiked() {
  try {
    return JSON.parse(localStorage.getItem('likedTracks') || "[]");
  } catch(e) {
    return [];
  }
}

function saveLiked(arr) {
  localStorage.setItem('likedTracks', JSON.stringify(arr));
}

function isLiked(idx) {
  const liked = getLiked();
  return liked.indexOf(idx) !== -1;
}

// Сохраняем оригинальную функцию
window.originalToggleLike = function(idx, e) {
  if (e) {
    e.stopPropagation();
  }
  
  let liked = getLiked();
  const wasLiked = liked.indexOf(idx) !== -1;
  
  if (wasLiked) {
    liked = liked.filter(i => i !== idx);
  } else {
    liked.push(idx);
  }
  
  saveLiked(liked);
  
  const star = e ? e.target : document.querySelector(`#trk${idx} .like-star`);
  if (star) {
    star.src = wasLiked ? 'img/star2.png' : 'img/star.png';
    star.title = wasLiked ? 'Добавить в понравившиеся' : 'Убрать из понравившихся';
    
    star.classList.add('animating');
    setTimeout(() => {
      star.classList.remove('animating');
    }, 300);
  }
};

// Обновлённая функция toggleLike с поддержкой фильтров
function toggleLike(idx, e) {
  // Вызываем оригинальную функцию (визуал, сохранение)
  window.originalToggleLike(idx, e);

  // Если активен фильтр — обновляем классы видимости и информируем
  if (favoritesFilterActive) {
    updateFavoriteClasses();
    const trackList = document.getElementById('track-list');
    const visibleCount = trackList.querySelectorAll('.track.is-favorite').length;

    if (visibleCount === 0) {
      toggleFavoritesFilter();
      NotificationSystem.warning('Все треки удалены из избранного, фильтр отключён');
    } else {
      const btn = document.getElementById('filter-favorites-btn');
      if (btn && btn.classList.contains('filtered')) {
        NotificationSystem.info(`⭐ Избранных треков: ${visibleCount}`);
      }
    }
  }

  // Если включён режим воспроизведения только избранных — поддерживаем корректный плейлист/переключения
  if (favoritesOnlyMode) {
    updateAvailableTracks();
    if (!isLiked(currentTrack)) {
      const nextFavorite = getNextFavoriteTrack();
      if (nextFavorite !== -1) {
        NotificationSystem.info('Переключаем на следующий избранный трек');
        setTimeout(() => showTrack(nextFavorite, true), 500);
      } else {
        toggleFavoritesOnly();
        NotificationSystem.warning('Все треки удалены из избранного');
      }
    }
    if (shuffleMode) {
      createShuffledPlaylist();
    }
  }

  // ВАЖНО: всегда (один раз) обновляем статистику избранного и проверяем ачивки по лайкам
  const likedCountNow = getLiked().length;
  Stats.onLikedCountChanged(likedCountNow);
  Ach.evaluateFromLikes();
}

// ==================== ФИЛЬТР ИЗБРАННЫХ В СПИСКЕ (ИСПРАВЛЕНО) ====================
function toggleFavoritesFilter() {
  const btn = document.getElementById('filter-favorites-btn');
  const trackList = document.getElementById('track-list');
  const liked = getLiked();
  
  favoritesFilterActive = !favoritesFilterActive;
  
  if (favoritesFilterActive) {
    if (liked.length === 0) {
      NotificationSystem.warning('Нет избранных треков! Отметьте треки звёздочкой ⭐');
      favoritesFilterActive = false;
      return;
    }
    
    btn.textContent = 'ПОКАЗАТЬ ВСЕ ПЕСНИ';
    btn.classList.add('filtered');
    trackList.classList.add('filtered');
    
    updateFavoriteClasses();
    
    const visibleCount = trackList.querySelectorAll('.track.is-favorite').length;
    
    if (visibleCount === 0) {
      showNoFavoritesMessage();
    } else {
      NotificationSystem.success(`⭐ Показаны только избранные (${visibleCount} треков)`);
      
      setTimeout(() => {
        const firstFavorite = trackList.querySelector('.track.is-favorite');
        if (firstFavorite) {
          firstFavorite.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
      }, 100);
    }
    
    localStorage.setItem('favoritesFilter', '1');
    
    // ИСПРАВЛЕНО: Автоматически включаем режим воспроизведения избранных
    if (!favoritesOnlyMode) {
      favoritesOnlyMode = true;
      updateAvailableTracks();
      const btn = document.getElementById('favorites-btn');
      const icon = document.getElementById('favorites-btn-icon');
      if (btn) btn.classList.add('favorites-active');
      if (icon) icon.src = 'img/star.png';
      localStorage.setItem('favoritesOnlyMode', '1');
    }
    
  } else {
    btn.textContent = 'Скрыть не отмеченные ⭐ песни';
    btn.classList.remove('filtered');
    trackList.classList.remove('filtered');
    
    const noFavMsg = document.getElementById('no-favorites-msg');
    if (noFavMsg) noFavMsg.remove();
    
    NotificationSystem.info('Показаны все треки');
    
    localStorage.removeItem('favoritesFilter');
    
    // ИСПРАВЛЕНО: Автоматически отключаем режим воспроизведения избранных
    if (favoritesOnlyMode) {
      favoritesOnlyMode = false;
      updateAvailableTracks();
      const btn = document.getElementById('favorites-btn');
      const icon = document.getElementById('favorites-btn-icon');
      if (btn) btn.classList.remove('favorites-active');
      if (icon) icon.src = 'img/star2.png';
      localStorage.setItem('favoritesOnlyMode', '0');
    }
    
    if (currentTrack >= 0) {
      setTimeout(() => {
        document.getElementById(`trk${currentTrack}`)?.scrollIntoView({ 
          behavior: 'smooth', 
          block: 'center' 
        });
      }, 100);
    }
  }
}

function updateFavoriteClasses() {
  const liked = getLiked();
  
  document.querySelectorAll('.track').forEach(track => {
    track.classList.remove('is-favorite');
  });
  
  liked.forEach(idx => {
    const trackEl = document.getElementById(`trk${idx}`);
    if (trackEl) {
      trackEl.classList.add('is-favorite');
    }
  });
}

function showNoFavoritesMessage() {
  const oldMsg = document.getElementById('no-favorites-msg');
  if (oldMsg) oldMsg.remove();
  
  const msg = document.createElement('div');
  msg.id = 'no-favorites-msg';
  msg.className = 'no-favorites-message';
  msg.innerHTML = `
    <div class="star-icon">⭐</div>
    <div>Нет избранных треков</div>
    <div style="font-size: 0.9em; margin-top: 10px; opacity: 0.7;">
      Отметьте понравившиеся треки звёздочкой<br>
      чтобы добавить их в избранное
    </div>
  `;
  
  const trackList = document.getElementById('track-list');
  trackList.appendChild(msg);
}

// ==================== СПИСОК ТРЕКОВ ====================
function buildTrackList() {
  const audio = document.getElementById('audio');
  let audioState = null;
  if (audio && currentTrack >= 0) {
    audioState = {
      currentTime: audio.currentTime,
      paused: audio.paused,
      volume: audio.volume
    };
  }
  
  let html = "";
  for (let i = 0; i < config.tracks.length; i++) {
    html += `<div class="track${i === currentTrack ? ' current' : ''}" id="trk${i}" onclick="pickAndPlayTrack(${i})">
      <span class="tnum">${(i + 1).toString().padStart(2, '0')}.</span>
      <span class="track-title">${config.tracks[i].title}</span>
      <img src="${isLiked(i) ? 'img/star.png' : 'img/star2.png'}" 
        class="like-star"
        alt="звезда" 
        title="${isLiked(i) ? 'Убрать из понравившихся' : 'Добавить в понравившиеся'}"
        onclick="toggleLike(${i}, event)"/>
    </div>`;
    
    if (i === currentTrack) {
      html += `<div class="lyrics-player-block" id="lyricsplayerblock"></div>`;
    }
  }
  
  if (DOM.trackList) {
    DOM.trackList.innerHTML = html;
  }
  
  // Восстанавливаем фильтр если был активен
  if (favoritesFilterActive) {
    const trackList = document.getElementById('track-list');
    if (trackList) {
      trackList.classList.add('filtered');
      updateFavoriteClasses();
    }
  }
  
  if (currentTrack >= 0) {
    renderLyricsBlock();
    
    if (audioState) {
      setTimeout(() => {
        const newAudio = document.getElementById('audio');
        if (newAudio) {
          newAudio.currentTime = audioState.currentTime;
          newAudio.volume = audioState.volume;
          if (!audioState.paused) {
            newAudio.play().catch(e => console.log('Autoplay prevented:', e));
          }
        }
      }, 100);
    }
  }
}

// ==================== ПРОИГРЫВАТЕЛЬ ====================
function pickAndPlayTrack(n) {
  // ИСПРАВЛЕНО: Очищаем позицию при ручном выборе трека
  PositionManager.clear();
  showTrack(n, true);
  autoPlayEnabled = true;
}

function showTrack(n, doPlay) {
  // ИСПРАВЛЕНО: Сохраняем позицию только текущего трека
  if (currentTrack >= 0 && currentTrack !== n) {
    const audio = document.getElementById('audio');
    if (audio) {
      PositionManager.save(`track_${currentTrack}`, audio.currentTime);
    }
  }
  
  currentTrack = n;
  buildTrackList();
  
  // ИСПРАВЛЕНО: Проверяем позицию только если это тот же трек
  if (!doPlay) {
    setTimeout(() => {
      checkAndRestorePosition();
    }, 100);
  }
  
  if (doPlay && document.getElementById("audio")) {
    setTimeout(() => {
      const audio = document.getElementById("audio");
      audio.currentTime = 0; // ИСПРАВЛЕНО: Всегда начинаем с начала при ручном выборе
      audio.play();
    }, 140);
  }
}

// ИСПРАВЛЕННАЯ функция проверки и восстановления позиции
function checkAndRestorePosition() {
  if (currentTrack < 0) return;
  
  const trackId = `track_${currentTrack}`;
  const savedPosition = PositionManager.get(trackId);
  
  if (savedPosition && savedPosition > 0) {
    const audio = document.getElementById('audio');
    if (audio) {
      audio.currentTime = savedPosition;
      NotificationSystem.info(`Продолжено с ${formatTime(savedPosition)}`);
    }
  }
}

// ИСПРАВЛЕННАЯ функция сохранения позиции
function saveCurrentPosition() {
  const audio = document.getElementById('audio');
  if (!audio || currentTrack < 0) return;
  
  const trackId = `track_${currentTrack}`;
  PositionManager.save(trackId, audio.currentTime);
}
// ==================== НОВЫЙ ПЛЕЕР С КОНТРОЛАМИ (ИСПРАВЛЕНО) ====================
function renderLyricsBlock() {
  const block = document.getElementById('lyricsplayerblock');
  if (!block) return;
  
  let lyricsDiv = `
    <div id="lyrics-window" class="lyrics-${lyricsViewMode}">
      <div class="lyrics-animated-bg${animationEnabled ? ' active' : ''}"></div>
      <div class="lyrics-scroll" id="lyrics"></div>
    </div>
    
    <!-- Прогресс бар трека БЕЗ ВРЕМЕНИ -->
    <div class="player-progress-wrapper">
      <div class="player-progress-bar" id="player-progress-bar">
        <div class="player-progress-fill" id="player-progress-fill">
          <div class="player-progress-handle"></div>
        </div>
      </div>
    </div>
    
    <div class="audio-wrapper">
      <audio id="audio" preload="metadata" aria-hidden="true" tabindex="-1"></audio>
    </div>
    
    <!-- НОВАЯ двухуровневая панель управления с временем -->
    <div class="player-controls" role="group" aria-label="Управление воспроизведением">
      <!-- Первый ряд с временем -->
      <div class="player-controls-row">
        <span class="time-in-controls" id="time-elapsed">00:00</span>
        
        <button class="player-control-btn" onclick="previousTrack()" 
                title="Предыдущий трек (P)" aria-label="Предыдущий трек">
          <span class="tooltip">P</span>
          <svg viewBox="0 0 24 24" fill="currentColor">
            <path d="M11 5L4 12l7 7V5zm9 0v14l-7-7 7-7z"/>
          </svg>
        </button>
        
        <button class="player-control-btn main" onclick="togglePlayPause()" 
                title="Воспроизведение/Пауза (K/Пробел)" aria-label="Воспроизведение/Пауза">
          <span class="tooltip">K</span>
          <svg id="play-pause-icon" viewBox="0 0 24 24" fill="currentColor">
            <path d="M8 5v14l11-7z"/>
          </svg>
        </button>
        
        <button class="player-control-btn" onclick="stopPlayback()" 
                title="Стоп (X)" aria-label="Стоп">
          <span class="tooltip">X</span>
          <svg viewBox="0 0 24 24" fill="currentColor">
            <rect x="6" y="6" width="12" height="12"/>
          </svg>
        </button>
        
        <button class="player-control-btn" onclick="nextTrack()" 
                title="Следующий трек (N)" aria-label="Следующий трек">
          <span class="tooltip">N</span>
          <svg viewBox="0 0 24 24" fill="currentColor">
            <path d="M13 5l7 7-7 7V5zM4 5v14l7-7-7-7z"/>
          </svg>
        </button>
        
        <span class="time-in-controls" id="time-remaining">--:--</span>
      </div>
      
      <!-- Второй ряд в правильном порядке -->
      <div class="player-controls-row">
        <button class="player-control-btn" id="mute-btn" onclick="toggleMute()" 
                title="Выключить звук (M)" aria-label="Выключить звук">
          <span class="tooltip">M</span>
          <svg viewBox="0 0 24 24" fill="currentColor">
            <path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02z"/>
          </svg>
        </button>
        
        <button class="player-control-btn${shuffleMode ? ' active' : ''}" 
                id="shuffle-btn" onclick="toggleShuffle()" 
                title="Случайный порядок (U)" aria-label="Случайный порядок">
          <span class="tooltip">U</span>
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M3 17h2.735a4 4 0 003.43-1.942l3.67-6.116A4 4 0 0116.265 7H21m0 0l-3-3m3 3l-3 3"/>
            <path d="M3 7h2.735a4 4 0 013.43 1.942l3.67 6.116A4 4 0 0016.265 17H21m0 0l-3 3m3-3l-3-3"/>
          </svg>
        </button>
        
        <button class="player-control-btn animation-btn${animationEnabled ? ' animation-active' : ''}" 
                id="animation-btn" onclick="toggleAnimation()" 
                title="Анимация лирики (A)" aria-label="Анимация лирики">
          <span class="tooltip">A</span>
          A
        </button>
        
        <button class="player-control-btn bit-btn${bitEnabled ? ' bit-active' : ''}" 
                id="bit-btn" onclick="toggleBit()" 
                title="Пульсация логотипа (B)" aria-label="Пульсация логотипа">
          <span class="tooltip">B</span>
          B
        </button>
        
        <button class="player-control-btn${repeatMode ? ' repeat-active' : ''}" 
                id="repeat-btn" onclick="toggleRepeat()" 
                title="Повтор трека (R)" aria-label="Повтор трека">
          <span class="tooltip">R</span>
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M17 2l4 4-4 4"/>
            <path d="M3 11V9a4 4 0 014-4h14"/>
            <path d="M7 22l-4-4 4-4"/>
            <path d="M21 13v2a4 4 0 01-4 4H3"/>
            <circle cx="12" cy="12" r="1" fill="currentColor" stroke="none"/>
          </svg>
        </button>
        
        <!-- Sleep таймер -->
        <button class="sleep-timer-btn" id="sleep-timer-btn" onclick="toggleSleepMenu()"
                title="Таймер сна (T)" aria-label="Таймер сна: выключен">
          <span class="tooltip">T</span>
          <svg viewBox="0 0 24 24" fill="currentColor" width="24" height="24">
            <path d="M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10 10-4.5 10-10S17.5 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm.5-13H11v6l5.2 3.2.8-1.3-4.5-2.7V7z"/>
          </svg>
          <span class="sleep-timer-badge" id="sleep-timer-badge" style="display:none;">0</span>
          
          <!-- Sleep меню -->
          <div class="sleep-menu" id="sleep-menu">
            <div class="sleep-menu-item" onclick="setSleepTimer('off')">Выключить</div>
            <div class="sleep-menu-item" onclick="setSleepTimer(15)">15 минут</div>
            <div class="sleep-menu-item" onclick="setSleepTimer(30)">30 минут</div>
            <div class="sleep-menu-item" onclick="setSleepTimer(60)">60 минут</div>
            <div class="sleep-menu-item" onclick="showTimePickerForSleep()">К времени...</div>
          </div>
        </button>
        
        <button class="player-control-btn${favoritesOnlyMode ? ' favorites-active' : ''}" 
                id="favorites-btn" onclick="toggleFavoritesOnly()" 
                title="Только избранные (F)" aria-label="Только избранные">
          <span class="tooltip">F</span>
          <img src="img/${favoritesOnlyMode ? 'star.png' : 'star2.png'}" alt="★" id="favorites-btn-icon"/>
        </button>
      </div>
    </div>
    
    <!-- Контроль громкости -->
    <div class="volume-control-wrapper">
      <div class="volume-header">
        <div class="volume-icon" onclick="toggleMute()">
          <svg id="volume-icon" viewBox="0 0 24 24">
            <path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/>
          </svg>
        </div>
        <span class="volume-percentage" id="volume-percentage">100%</span>
      </div>
      <div class="volume-slider-container">
        <div class="volume-track"></div>
        <div class="volume-fill" id="volume-fill"></div>
        <input type="range" class="volume-slider" id="volume-slider" 
               min="0" max="100" value="100" 
               aria-label="Громкость"
               aria-valuemin="0" aria-valuemax="100" aria-valuenow="100">
      </div>
    </div>
    
    <div class="player-buttons-wrapper">
      <button class="lyrics-toggle-btn lyrics-${lyricsViewMode}" 
              onclick="toggleLyricsView()" 
              aria-label="${getLyricsButtonLabel()}"
              title="${getLyricsButtonLabel()} (Y)">
        <span class="lyrics-toggle-btn-visual">Т</span>
      </button>
      <button class="karaoke-btn" onclick="copyLyrics()">СКОПИРОВАТЬ ТЕКСТ</button>
      <a class="player-download-btn" href="#" onclick="openDownloadModal(event)">СКАЧАТЬ ПЕСНЮ</a>
    </div>`;
  
  block.innerHTML = lyricsDiv;
  
  const tr = config.tracks[currentTrack];
  const audioEl = document.getElementById('audio');
  audioEl.src = tr.audio;
  
  loadLyrics(tr.lyrics);
  setupMediaSession();
  restorePlayerButtonsState();
  initializePlayerControls();
  
  // Инициализируем режим лирики
  initializeLyricsMode();
  applyLyricsViewMode();
  
  // ИСПРАВЛЕНО: Переинициализируем Web Audio API при каждой смене трека
  if (bitEnabled) {
    // Останавливаем старую анимацию
    stopLogoPulsation();
    
    // Сбрасываем аудио контекст
    audioContext = null;
    audioSource = null;
    analyser = null;
    
    // Ждём загрузки аудио и инициализируем заново
    setTimeout(() => {
      initAudioContext();
      startLogoPulsation();
    }, 100);
  }
  
  // События аудио
  audioEl.addEventListener('loadedmetadata', onAudioMetadataLoaded);
  audioEl.addEventListener('timeupdate', onAudioTimeUpdate);
  audioEl.addEventListener('seeking', onAudioSeeking);
  audioEl.addEventListener('seeked', onAudioSeeked);
  audioEl.addEventListener('ended', onAudioEnded);
  audioEl.addEventListener('volumechange', onVolumeChange);
  audioEl.addEventListener('play', () => {
   if (bitEnabled && audioContext && audioContext.state === 'suspended') {
     audioContext.resume();
   }
   Stats.onStart(currentTrack);                // ВСТАВЛЕНО
   updatePlayPauseIcon();
 });

audioEl.addEventListener('pause', () => {     // ВСТАВЛЕНО
  Stats.onPauseOrStop({ ended: false });      // ВСТАВЛЕНО
  updatePlayPauseIcon();
});

  
  // НОВОЕ: Переинициализация при загрузке нового трека
  audioEl.addEventListener('canplay', () => {
    if (bitEnabled && !analyser) {
      initAudioContext();
      startLogoPulsation();
    }
  });
}

// ==================== КАСТОМНЫЙ ПЛЕЕР ====================
let lastTimeUpdate = 0;
let isSeekingProgress = false;
let isMuted = false;
let sleepTimerInterval = null;
let sleepTimerTarget = null;
let sleepTimerMode = null;
let hasShownIOSVolumeNotice = false;

// Инициализация контролов плеера
function initializePlayerControls() {
  // Прогресс бар
  const progressBar = document.getElementById('player-progress-bar');
  if (progressBar) {
    progressBar.addEventListener('click', seekToPosition);
    progressBar.addEventListener('mousedown', startSeekDrag);
    progressBar.addEventListener('touchstart', startSeekDrag, { passive: false });
  }
  
  // Громкость
  const volumeSlider = document.getElementById('volume-slider');
  if (volumeSlider) {
    volumeSlider.addEventListener('input', onVolumeSliderChange);
    volumeSlider.addEventListener('change', onVolumeSliderChange);
    
    // Восстанавливаем сохранённую громкость
    const savedVolume = localStorage.getItem('playerVolume');
    if (savedVolume !== null) {
      const volume = parseFloat(savedVolume);
      volumeSlider.value = volume * 100;
      updateVolumeUI(volume);
      const audio = document.getElementById('audio');
      if (audio) audio.volume = volume;
    }
  }
  
  // Восстанавливаем sleep таймер если был
  restoreSleepTimer();
  
  // Восстанавливаем состояние анимаций
  if (animationEnabled) {
    const animBg = document.querySelector('.lyrics-animated-bg');
    const lyricsWindow = document.getElementById('lyrics-window');
    if (animBg) animBg.classList.add('active');
    if (lyricsWindow) lyricsWindow.classList.add('animation-active');
  }
} 
// Форматирование времени
function formatTime(seconds) {
  if (isNaN(seconds) || seconds < 0) return '--:--';
  const mins = Math.floor(seconds / 60);
  const secs = Math.floor(seconds % 60);
  return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
}

// События аудио
function onAudioMetadataLoaded() {
  const audio = document.getElementById('audio');
  const duration = audio.duration;
  
  const elapsedEl = document.getElementById('time-elapsed');
  const remainingEl = document.getElementById('time-remaining');
  
  if (elapsedEl) elapsedEl.textContent = '00:00';
  if (remainingEl) remainingEl.textContent = formatTime(duration);
  
  // Доступность
  audio.setAttribute('aria-label', `Трек ${currentTrack + 1}, длительность ${formatTime(duration)}`);
}

function onAudioTimeUpdate() {
  const audio = document.getElementById('audio');
  const currentTime = audio.currentTime;
  const duration = audio.duration;
  
  // Обновляем прогресс бар ВСЕГДА для плавности
  if (!isSeekingProgress && duration > 0) {
    const progress = (currentTime / duration) * 100;
    const fillEl = document.getElementById('player-progress-fill');
    if (fillEl) fillEl.style.width = `${progress}%`;
  }
  
  // Обновляем лирику ВСЕГДА для синхронизации
  renderLyricsEnhanced(currentTime);
  
  // Обновляем время только раз в секунду
  const now = Date.now();
  if (now - lastTimeUpdate >= 1000) {
    lastTimeUpdate = now;
    
    // Обновляем таймеры
    const elapsedEl = document.getElementById('time-elapsed');
    const remainingEl = document.getElementById('time-remaining');
    
    if (elapsedEl) elapsedEl.textContent = formatTime(currentTime);
    if (remainingEl) remainingEl.textContent = formatTime(duration - currentTime);
    
    // Проверяем sleep таймер
    checkSleepTimer();
  }
  
  updatePlayPauseIcon();
}

function onAudioSeeking() {
  // Можно показать индикатор загрузки
}

function onAudioSeeked() {
  // Убираем индикатор загрузки
}

// ИСПРАВЛЕНО: Автопереход на следующий трек
function onAudioEnded() {
  // учёт завершённого прослушивания
  Stats.onPauseOrStop({ ended: true });
  const remainingEl = document.getElementById('time-remaining');
  if (remainingEl) remainingEl.textContent = '00:00';
  
  // Очищаем позицию завершившегося трека
  PositionManager.clear();
  
  if (repeatMode) {
    const audio = document.getElementById('audio');
    audio.currentTime = 0;
    audio.play();
  } else {
    // ИСПРАВЛЕНО: Всегда переходим на следующий трек
    nextTrack();
  }
}

// Прогресс бар - перемотка
function seekToPosition(e) {
  const audio = document.getElementById('audio');
  const progressBar = e.currentTarget;
  const rect = progressBar.getBoundingClientRect();
  const percent = (e.clientX - rect.left) / rect.width;
  const time = audio.duration * Math.max(0, Math.min(1, percent));
  
  audio.currentTime = time;
}

function startSeekDrag(e) {
  isSeekingProgress = true;
  
  const moveHandler = (e) => {
    const progressBar = document.getElementById('player-progress-bar');
    const rect = progressBar.getBoundingClientRect();
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const percent = Math.max(0, Math.min(1, (clientX - rect.left) / rect.width));
    
    const fillEl = document.getElementById('player-progress-fill');
    if (fillEl) fillEl.style.width = `${percent * 100}%`;
  };
  
  const endHandler = (e) => {
    const progressBar = document.getElementById('player-progress-bar');
    const rect = progressBar.getBoundingClientRect();
    const clientX = e.changedTouches ? e.changedTouches[0].clientX : e.clientX;
    const percent = Math.max(0, Math.min(1, (clientX - rect.left) / rect.width));
    
    const audio = document.getElementById('audio');
    audio.currentTime = audio.duration * percent;
    
    isSeekingProgress = false;
    
    document.removeEventListener('mousemove', moveHandler);
    document.removeEventListener('mouseup', endHandler);
    document.removeEventListener('touchmove', moveHandler);
    document.removeEventListener('touchend', endHandler);
  };
  
  document.addEventListener('mousemove', moveHandler);
  document.addEventListener('mouseup', endHandler);
  document.addEventListener('touchmove', moveHandler);
  document.addEventListener('touchend', endHandler);
  
  e.preventDefault();
}
// Громкость
function onVolumeSliderChange(e) {
  const value = e.target.value / 100;
  const audio = document.getElementById('audio');
  
  // Проверяем iOS
  const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
  
  if (audio) {
    audio.volume = value;
    
    // На iOS показываем уведомление один раз
    if (isIOS && !hasShownIOSVolumeNotice && value !== audio.volume) {
      hasShownIOSVolumeNotice = true;
      showIOSVolumeNotice();
    }
  }
  
  updateVolumeUI(value);
  
  // Сохраняем значение
  localStorage.setItem('playerVolume', value);
  PlayerState.save();
}

function onVolumeChange() {
  const audio = document.getElementById('audio');
  const volume = audio.volume;
  const slider = document.getElementById('volume-slider');
  
  if (slider) {
    slider.value = volume * 100;
  }
  
  updateVolumeUI(volume);
}

function updateVolumeUI(volume) {
  const percentage = Math.round(volume * 100);
  const percentEl = document.getElementById('volume-percentage');
  const fillEl = document.getElementById('volume-fill');
  
  if (percentEl) percentEl.textContent = `${percentage}%`;
  if (fillEl) fillEl.style.width = `${percentage}%`;
  
  // Обновляем иконку
  const icon = document.getElementById('volume-icon');
  const muteBtn = document.getElementById('mute-btn');
  
  if (icon) {
    if (volume === 0 || isMuted) {
      icon.innerHTML = '<path d="M16.5 12c0-1.77-1.02-3.29-2.5-4.03v2.21l2.45 2.45c.03-.2.05-.41.05-.63zm2.5 0c0 .94-.2 1.82-.54 2.64l1.51 1.51C20.63 14.91 21 13.5 21 12c0-4.28-2.99-7.86-7-8.77v2.06c2.89.86 5 3.54 5 6.71zM4.27 3L3 4.27 7.73 9H3v6h4l5 5v-6.73l4.25 4.25c-.67.52-1.42.93-2.25 1.18v2.06c1.38-.31 2.63-.95 3.69-1.81L19.73 21 21 19.73l-9-9L4.27 3zM12 4L9.91 6.09 12 8.18V4z"/>';
      if (muteBtn) muteBtn.classList.add('active');
    } else if (volume < 0.5) {
      icon.innerHTML = '<path d="M7 9v6h4l5 5V4l-5 5H7z"/>';
      if (muteBtn) muteBtn.classList.remove('active');
    } else {
      icon.innerHTML = '<path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/>';
      if (muteBtn) muteBtn.classList.remove('active');
    }
  }
  
  // Обновляем aria
  const slider = document.getElementById('volume-slider');
  if (slider) {
    slider.setAttribute('aria-valuenow', percentage);
  }
}

function toggleMute() {
  const audio = document.getElementById('audio');
  if (!audio) return;
  
  if (isMuted) {
    audio.volume = parseFloat(localStorage.getItem('playerVolume') || 1);
    isMuted = false;
  } else {
    localStorage.setItem('playerVolume', audio.volume);
    audio.volume = 0;
    isMuted = true;
  }
  
  updateVolumeUI(audio.volume);
}

function showIOSVolumeNotice() {
  const notice = document.createElement('div');
  notice.className = 'ios-volume-notice';
  notice.textContent = 'На iPhone громкость регулируется системными кнопками';
  document.body.appendChild(notice);
  
  setTimeout(() => {
    notice.classList.add('show');
  }, 100);
  
  setTimeout(() => {
    notice.classList.remove('show');
    setTimeout(() => notice.remove(), 300);
  }, 3000);
}

// ==================== SLEEP ТАЙМЕР ====================
function toggleSleepMenu() {
  const menu = document.getElementById('sleep-menu');
  menu.classList.toggle('active');
  
  // Закрываем при клике вне меню
  if (menu.classList.contains('active')) {
    setTimeout(() => {
      document.addEventListener('click', closeSleepMenu);
    }, 100);
  }
}

function closeSleepMenu(e) {
  if (e && e.target.closest('#sleep-timer-btn')) return;
  
  const menu = document.getElementById('sleep-menu');
  menu.classList.remove('active');
  document.removeEventListener('click', closeSleepMenu);
}

function setSleepTimer(minutes) {
  closeSleepMenu();
  
  if (minutes === 'off') {
    clearSleepTimer();
    return;
  }
  
  // Устанавливаем таймер
  sleepTimerMode = minutes;
  sleepTimerTarget = Date.now() + (minutes * 60 * 1000);
  
  // Сохраняем в localStorage
  localStorage.setItem('sleepTimer', JSON.stringify({
    mode: sleepTimerMode,
    target: sleepTimerTarget,
    setAt: Date.now()
  }));
  
  // Обновляем UI
  updateSleepTimerUI();
  
  // Показываем уведомление
  NotificationSystem.info(`Таймер сна установлен на ${minutes} минут`);
  
  // Запускаем интервал обновления
  if (sleepTimerInterval) clearInterval(sleepTimerInterval);
  sleepTimerInterval = setInterval(updateSleepTimerUI, 1000);
}

function showTimePickerForSleep() {
  closeSleepMenu();
  
  // Создаём модальное окно для выбора времени
  const modal = document.createElement('div');
  modal.className = 'modal-bg active';
  modal.innerHTML = `
    <div class="modal-feedback" style="max-width: 300px;">
      <button class="bigclose" onclick="this.closest('.modal-bg').remove()" title="Закрыть">
        <svg viewBox="0 0 48 48">
          <line x1="12" y1="12" x2="36" y2="36" stroke="currentColor" stroke-width="6" stroke-linecap="round"/>
          <line x1="36" y1="12" x2="12" y2="36" stroke="currentColor" stroke-width="6" stroke-linecap="round"/>
        </svg>
      </button>
      <h3>Установить таймер до:</h3>
      <div style="display: flex; gap: 10px; justify-content: center; margin: 20px 0;">
        <input type="number" id="sleep-hour" min="0" max="23" value="${new Date().getHours()}" 
               style="width: 60px; padding: 10px; text-align: center; background: rgba(255,255,255,0.1); 
                      border: 1px solid var(--border-color); border-radius: 8px; color: white;">
        <span style="font-size: 24px;">:</span>
        <input type="number" id="sleep-minute" min="0" max="59" value="${new Date().getMinutes() + 30}" 
               style="width: 60px; padding: 10px; text-align: center; background: rgba(255,255,255,0.1);
                      border: 1px solid var(--border-color); border-radius: 8px; color: white;">
      </div>
      <button onclick="setSleepTimerToTime()" class="btn-primary" style="width: 100%;">Установить</button>
    </div>
  `;
  document.body.appendChild(modal);
}

function setSleepTimerToTime() {
  const hour = parseInt(document.getElementById('sleep-hour').value);
  const minute = parseInt(document.getElementById('sleep-minute').value);
  
  const now = new Date();
  const target = new Date();
  target.setHours(hour, minute, 0, 0);
  
  // Если время уже прошло сегодня, устанавливаем на завтра
  if (target <= now) {
    target.setDate(target.getDate() + 1);
  }
  
  sleepTimerMode = 'time';
  sleepTimerTarget = target.getTime();
  
  // Сохраняем
  localStorage.setItem('sleepTimer', JSON.stringify({
    mode: sleepTimerMode,
    target: sleepTimerTarget,
    setAt: Date.now()
  }));
  
  // Закрываем модальное окно
  document.querySelector('.modal-bg').remove();
  
  // Обновляем UI
  updateSleepTimerUI();
  
  // Уведомление
  NotificationSystem.info(`Таймер сна установлен на ${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`);
  
  // Запускаем интервал
  if (sleepTimerInterval) clearInterval(sleepTimerInterval);
  sleepTimerInterval = setInterval(updateSleepTimerUI, 1000);
}

function clearSleepTimer() {
  sleepTimerMode = null;
  sleepTimerTarget = null;
  
  if (sleepTimerInterval) {
    clearInterval(sleepTimerInterval);
    sleepTimerInterval = null;
  }
  
  localStorage.removeItem('sleepTimer');
  
  // Обновляем UI
  const btn = document.getElementById('sleep-timer-btn');
  if (btn) {
    btn.classList.remove('active');
    btn.setAttribute('aria-label', 'Таймер сна: выключен');
  }
  
  const badge = document.getElementById('sleep-timer-badge');
  if (badge) badge.style.display = 'none';
  
  NotificationSystem.info('Таймер сна отключён');
}

function updateSleepTimerUI() {
  if (!sleepTimerTarget) return;
  
  const now = Date.now();
  const remaining = sleepTimerTarget - now;
  
  if (remaining <= 0) {
    // Таймер истёк
    executeSleepTimer();
    return;
  }
  
  // Обновляем бейдж
  const minutes = Math.ceil(remaining / 60000);
  const badge = document.getElementById('sleep-timer-badge');
  if (badge) {
    badge.textContent = minutes;
    badge.style.display = 'block';
  }
  
  // Обновляем aria-label
  const btn = document.getElementById('sleep-timer-btn');
  if (btn) {
    btn.classList.add('active');
    btn.setAttribute('aria-label', `Таймер сна: осталось ${minutes} минут`);
  }
}

function executeSleepTimer() {
  // Останавливаем воспроизведение
  const audio = document.getElementById('audio');
  if (audio && !audio.paused) {
    audio.pause();
  }
  
  // Очищаем медиа-сессию
  if ('mediaSession' in navigator) {
    navigator.mediaSession.metadata = null;
  }
  
  // Очищаем таймер
  clearSleepTimer();
  
  // Показываем оверлей
  showSleepOverlay();
}

function showSleepOverlay() {
  const overlay = document.createElement('div');
  overlay.className = 'sleep-overlay active';
  overlay.innerHTML = `
    <div class="sleep-content">
      <div class="sleep-icon">😴</div>
      <h2 class="sleep-title">Таймер сна сработал</h2>
      <p class="sleep-message">Воспроизведение остановлено</p>
      <div class="sleep-buttons">
        <button class="sleep-btn sleep-btn-primary" onclick="closeSleepOverlay()">Готово</button>
        <button class="sleep-btn sleep-btn-secondary" onclick="showCloseInstructions()">Закрыть приложение</button>
      </div>
    </div>
  `;
  document.body.appendChild(overlay);
}

function closeSleepOverlay() {
  const overlay = document.querySelector('.sleep-overlay');
  if (overlay) {
    overlay.classList.remove('active');
    setTimeout(() => overlay.remove(), 300);
  }
}

function showCloseInstructions() {
  const content = document.querySelector('.sleep-content');
  if (content) {
    content.innerHTML = `
      <div class="sleep-icon">📱</div>
      <h2 class="sleep-title">Как закрыть приложение</h2>
      <p class="sleep-message">
        <strong>iOS:</strong> Свайп вверх от нижнего края экрана<br>
        <strong>Android:</strong> Кнопка "Назад" или свайп<br>
        <strong>PWA:</strong> Закройте окно приложения
      </p>
      <button class="sleep-btn sleep-btn-primary" onclick="closeSleepOverlay()">Понятно</button>
    `;
  }
}

function restoreSleepTimer() {
  const saved = localStorage.getItem('sleepTimer');
  if (!saved) return;
  
  try {
    const data = JSON.parse(saved);
    
    if (data.target > Date.now()) {
      // Таймер ещё активен
      sleepTimerMode = data.mode;
      sleepTimerTarget = data.target;
      
      updateSleepTimerUI();
      
      // Запускаем интервал
      if (sleepTimerInterval) clearInterval(sleepTimerInterval);
      sleepTimerInterval = setInterval(updateSleepTimerUI, 1000);
    } else {
      // Таймер истёк пока приложение было закрыто
      executeSleepTimer();
    }
  } catch (e) {
    console.error('Failed to restore sleep timer:', e);
  }
}

function checkSleepTimer() {
  if (!sleepTimerTarget) return;
  
  if (Date.now() >= sleepTimerTarget) {
    executeSleepTimer();
  }
}

// Добавляем обработчики событий для сохранения позиции
window.addEventListener('beforeunload', saveCurrentPosition);
document.addEventListener('visibilitychange', () => {
  if (document.hidden) {
    saveCurrentPosition();
  }
});

// Периодическое сохранение позиции (каждые 10 секунд)
setInterval(() => {
  const audio = document.getElementById('audio');
  if (audio && !audio.paused) {
    saveCurrentPosition();
  }
}, 10000);

// Вспомогательная функция для получения текста кнопки
function getLyricsButtonLabel() {
  const labels = {
    'normal': 'Скрыть лирику',
    'hidden': 'Показать лирику (увеличенный вид)',
    'expanded': 'Показать лирику (обычный размер)'
  };
  return labels[lyricsViewMode] || 'Управление лирикой';
}

// ==================== УПРАВЛЕНИЕ ОТОБРАЖЕНИЕМ ЛИРИКИ ====================
let lyricsViewMode = 'normal'; // 'normal', 'hidden', 'expanded'
let lyricsUpdateInterval = null;

// Восстановление состояния лирики
function restoreLyricsViewMode() {
  const saved = localStorage.getItem('lyricsViewMode');
  if (saved && ['normal', 'hidden', 'expanded'].includes(saved)) {
    lyricsViewMode = saved;
  }
}

// Сохранение состояния лирики
function saveLyricsViewMode() {
  localStorage.setItem('lyricsViewMode', lyricsViewMode);
}

// Переключение режима отображения лирики
function toggleLyricsView() {
  // Цикл: normal → hidden → expanded → normal
  const modes = ['normal', 'hidden', 'expanded'];
  const currentIndex = modes.indexOf(lyricsViewMode);
  const nextIndex = (currentIndex + 1) % modes.length;
  lyricsViewMode = modes[nextIndex];
  
  applyLyricsViewMode();
  saveLyricsViewMode();
  
  // Уведомления
  const messages = {
    'normal': '📝 Обычный вид лирики',
    'hidden': '🚫 Лирика скрыта',
    'expanded': '📖 Расширенный вид лирики'
  };
  
  NotificationSystem.info(messages[lyricsViewMode]);
  
  // Логирование для аналитики
  console.log(`Lyrics mode changed to: ${lyricsViewMode}`);
}

// Применение режима отображения
function applyLyricsViewMode() {
  const lyricsWindow = document.getElementById('lyrics-window');
  const toggleBtn = document.querySelector('.lyrics-toggle-btn');
  
  if (!lyricsWindow || !toggleBtn) return;
  
  // Удаляем все классы режимов
  lyricsWindow.classList.remove('lyrics-normal', 'lyrics-hidden', 'lyrics-expanded');
  toggleBtn.classList.remove('lyrics-normal', 'lyrics-hidden', 'lyrics-expanded');
  
  // Добавляем текущий режим
  lyricsWindow.classList.add(`lyrics-${lyricsViewMode}`);
  toggleBtn.classList.add(`lyrics-${lyricsViewMode}`);
  
  // Обновляем aria-label и title
  const labels = {
    'normal': 'Скрыть лирику',
    'hidden': 'Показать лирику (увеличенный вид)',
    'expanded': 'Показать лирику (обычный размер)'
  };
  
  toggleBtn.setAttribute('aria-label', labels[lyricsViewMode]);
  toggleBtn.setAttribute('title', labels[lyricsViewMode] + ' (Y)');
  
  // Управление рендерингом лирики
  if (lyricsViewMode === 'hidden') {
    // Приостанавливаем визуальное обновление для экономии ресурсов
    pauseLyricsRendering();
  } else {
    // Возобновляем рендеринг и пересчитываем количество строк
    resumeLyricsRendering();
    updateLyricsWindowSize();
  }
}
// Приостановка рендеринга лирики
function pauseLyricsRendering() {
  const lyricsDiv = document.getElementById('lyrics');
  if (lyricsDiv) {
    lyricsDiv.style.display = 'none';
  }
}

// Возобновление рендеринга лирики
function resumeLyricsRendering() {
  const lyricsDiv = document.getElementById('lyrics');
  if (lyricsDiv) {
    lyricsDiv.style.display = '';
    const audio = document.getElementById('audio');
    if (audio && !audio.paused) {
      renderLyrics(audio.currentTime);
    }
  }
}

// Обновление размера окна лирики
function updateLyricsWindowSize() {
  const windowSize = lyricsViewMode === 'expanded' ? 9 : 5;
  const centerLine = Math.floor(windowSize / 2);
  
  // Обновляем глобальную переменную для правильного рендеринга
  window.lyricsWindowSize = windowSize;
  window.lyricsCenterLine = centerLine;
  
  // Перерисовываем лирику
  const audio = document.getElementById('audio');
  if (audio) {
    renderLyrics(audio.currentTime);
  }
}

// Модифицированная функция renderLyrics для поддержки разных размеров окна
function renderLyricsEnhanced(time) {
  // ИСПРАВЛЕНО: убираем лишние проверки для производительности
  if (lyricsViewMode === 'hidden') return;
  
  if (!currentLyrics || !currentLyrics.length) {
    const lyricsEl = document.getElementById('lyrics');
    if (lyricsEl) lyricsEl.innerHTML = "";
    return;
  }
  
  let active = 0;
  for (let i = 0; i < currentLyrics.length; i++) {
    if (time >= currentLyrics[i].time) active = i;
  }
  
  const windowSize = window.lyricsWindowSize || 5;
  const centerLine = window.lyricsCenterLine || 2;
  
  const start = Math.max(0, active - centerLine);
  const padTop = Math.max(0, centerLine - active);
  const rows = [];
  
  // Добавляем пустые строки сверху если нужно
  for (let p = 0; p < padTop; ++p) {
    rows.push('<div class="lyrics-window-line"></div>');
  }
  
  // Добавляем строки с текстом
  for (let i = start; i < Math.min(currentLyrics.length, start + windowSize - padTop); i++) {
    const cls = (i === active) ? 'lyrics-window-line active' : 'lyrics-window-line';
    rows.push(`<div class="${cls}">${currentLyrics[i] ? currentLyrics[i].line : ""}</div>`);
  }
  
  // Добавляем пустые строки снизу если нужно
  while (rows.length < windowSize) {
    rows.push('<div class="lyrics-window-line"></div>');
  }
  
  const lyricsEl = document.getElementById("lyrics");
  if (lyricsEl) lyricsEl.innerHTML = rows.join("");
}

// Инициализация режима лирики при загрузке
function initializeLyricsMode() {
  restoreLyricsViewMode();
  
  // Устанавливаем начальные значения для размера окна
  window.lyricsWindowSize = lyricsViewMode === 'expanded' ? 9 : 5;
  window.lyricsCenterLine = Math.floor(window.lyricsWindowSize / 2);
}

// ==================== ФУНКЦИИ УПРАВЛЕНИЯ ПЛЕЕРОМ ====================
function togglePlayPause() {
  const audio = document.getElementById('audio');
  if (!audio) return;
  
  if (audio.paused) {
    audio.play();
  } else {
    audio.pause();
  }
}

function updatePlayPauseIcon() {
  const audio = document.getElementById('audio');
  const icon = document.getElementById('play-pause-icon');
  if (!audio || !icon) return;
  
  if (audio.paused) {
    icon.innerHTML = '<path d="M8 5v14l11-7z"/>';
  } else {
    icon.innerHTML = '<path d="M6 6h4v12H6zM14 6h4v12h-4z"/>';
  }
}

function stopPlayback() {
  const audio = document.getElementById('audio');
  if (!audio) return;
  
  audio.pause();
  audio.currentTime = 0;
  updatePlayPauseIcon();
  
  // Очищаем позицию при остановке
  PositionManager.clear();
}

function toggleRepeat() {
  repeatMode = !repeatMode;
  const btn = document.getElementById('repeat-btn');
  
  if (repeatMode) {
    btn.classList.add('repeat-active');
    NotificationSystem.info('🔁 Повтор трека включён');
  } else {
    btn.classList.remove('repeat-active');
    NotificationSystem.info('Повтор трека выключен');
  }
  
  localStorage.setItem('repeatMode', repeatMode ? '1' : '0');
}

function toggleShuffle() {
  shuffleMode = !shuffleMode;
  const btn = document.getElementById('shuffle-btn');
  
  if (shuffleMode) {
    btn.classList.add('active');
    createShuffledPlaylist();
    
    if (favoritesOnlyMode) {
      const count = getLiked().length;
      NotificationSystem.info(`🔀 Случайный порядок включён (${count} избранных)`);
    } else {
      NotificationSystem.info('🔀 Случайный порядок включён');
    }
  } else {
    btn.classList.remove('active');
    NotificationSystem.info('Последовательное воспроизведение');
  }
  
  localStorage.setItem('shuffleMode', shuffleMode ? '1' : '0');
}

// ИСПРАВЛЕНО: Синхронизация с фильтром
function toggleFavoritesOnly() {
  const likedTracks = getLiked();
  
  if (likedTracks.length === 0) {
    NotificationSystem.warning('Нет избранных треков! Отметьте треки звёздочкой.');
    return;
  }
  
  // Проверяем блокировку от фильтра
  if (favoritesFilterActive && favoritesOnlyMode) {
    NotificationSystem.warning('Сначала нажмите ПОКАЗАТЬ ВСЕ ПЕСНИ');
    return;
  }
  
  favoritesOnlyMode = !favoritesOnlyMode;
  const btn = document.getElementById('favorites-btn');
  const icon = document.getElementById('favorites-btn-icon');
  
  if (favoritesOnlyMode) {
    btn.classList.add('favorites-active');
    icon.src = 'img/star.png';
    updateAvailableTracks();
    NotificationSystem.success(`⭐ Играют только избранные (${likedTracks.length} треков)`);
    
    if (!isLiked(currentTrack)) {
      const nextFavorite = getNextFavoriteTrack();
      if (nextFavorite !== -1) {
        showTrack(nextFavorite, true);
      }
    }
  } else {
    btn.classList.remove('favorites-active');
    icon.src = 'img/star2.png';
    updateAvailableTracks();
    NotificationSystem.info('Играют все треки');
  }
  
  if (shuffleMode) {
    createShuffledPlaylist();
  }
  
  localStorage.setItem('favoritesOnlyMode', favoritesOnlyMode ? '1' : '0');
}

function updateAvailableTracks() {
  if (favoritesOnlyMode) {
    availableTracks = getLiked();
  } else {
    availableTracks = Array.from({length: config.tracks.length}, (_, i) => i);
  }
}

function getNextFavoriteTrack() {
  const liked = getLiked();
  if (liked.length === 0) return -1;
  
  const currentIndex = liked.indexOf(currentTrack);
  if (currentIndex !== -1 && currentIndex < liked.length - 1) {
    return liked[currentIndex + 1];
  }
  
  return liked[0];
}

function previousTrack() {
  if (repeatMode) {
    const audio = document.getElementById('audio');
    if (audio) {
      audio.currentTime = 0;
      audio.play();
    }
    return;
  }
  
  updateAvailableTracks();
  
  if (availableTracks.length === 0) {
    NotificationSystem.warning('Нет доступных треков для воспроизведения');
    return;
  }
  
  // Очищаем позицию при переключении
  PositionManager.clear();
  
  if (shuffleMode) {
    shuffleIndex = Math.max(0, shuffleIndex - 1);
    if (shuffleIndex < shuffledPlaylist.length) {
      showTrack(shuffledPlaylist[shuffleIndex], true);
    }
  } else if (favoritesOnlyMode) {
    const currentIdx = availableTracks.indexOf(currentTrack);
    const prevIdx = currentIdx > 0 ? currentIdx - 1 : availableTracks.length - 1;
    showTrack(availableTracks[prevIdx], true);
  } else {
    const prev = currentTrack > 0 ? currentTrack - 1 : config.tracks.length - 1;
    showTrack(prev, true);
  }
}

function nextTrack() {
  if (repeatMode) {
    const audio = document.getElementById('audio');
    if (audio) {
      audio.currentTime = 0;
      audio.play();
    }
    return;
  }
  
  updateAvailableTracks();
  
  if (availableTracks.length === 0) {
    NotificationSystem.warning('Нет доступных треков для воспроизведения');
    return;
  }
  
  // Очищаем позицию при переключении
  PositionManager.clear();
  
  if (shuffleMode) {
    shuffleIndex++;
    if (shuffleIndex >= shuffledPlaylist.length) {
      createShuffledPlaylist();
      shuffleIndex = 0;
    }
    showTrack(shuffledPlaylist[shuffleIndex], true);
  } else if (favoritesOnlyMode) {
    const currentIdx = availableTracks.indexOf(currentTrack);
    const nextIdx = (currentIdx + 1) % availableTracks.length;
    showTrack(availableTracks[nextIdx], true);
  } else {
    const next = (currentTrack + 1) % config.tracks.length;
    showTrack(next, true);
  }
}

function createShuffledPlaylist() {
  updateAvailableTracks();
  
  shuffledPlaylist = [...availableTracks];
  
  const currentIdx = shuffledPlaylist.indexOf(currentTrack);
  if (currentIdx !== -1) {
    shuffledPlaylist.splice(currentIdx, 1);
  }
  
  for (let i = shuffledPlaylist.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [shuffledPlaylist[i], shuffledPlaylist[j]] = [shuffledPlaylist[j], shuffledPlaylist[i]];
  }
  
  if (availableTracks.includes(currentTrack)) {
    shuffledPlaylist.unshift(currentTrack);
  }
  
  shuffleIndex = 0;
}

function restorePlayerButtonsState() {
  if (shuffleMode) {
    document.getElementById('shuffle-btn')?.classList.add('active');
  }
  
  if (repeatMode) {
    document.getElementById('repeat-btn')?.classList.add('repeat-active');
  }
  
  if (favoritesOnlyMode) {
    const btn = document.getElementById('favorites-btn');
    const icon = document.getElementById('favorites-btn-icon');
    if (btn) btn.classList.add('favorites-active');
    if (icon) icon.src = 'img/star.png';
  }
  
  if (animationEnabled) {
    document.getElementById('animation-btn')?.classList.add('animation-active');
  }
  
  if (bitEnabled) {
    document.getElementById('bit-btn')?.classList.add('bit-active');
  }
}

// ==================== MEDIA SESSION API ====================
function setupMediaSession() {
  if ('mediaSession' in navigator) {
    const track = config.tracks[currentTrack];
    
    navigator.mediaSession.metadata = new MediaMetadata({
      title: track.title,
      artist: config.artist || 'Витрина Разбита',
      album: config.albumName || 'Между Злом и Добром',
      artwork: [
        { src: 'Cover.png', sizes: '512x512', type: 'image/png' },
        { src: 'icons/icon-192.png', sizes: '192x192', type: 'image/png' },
        { src: 'icons/icon-512.png', sizes: '512x512', type: 'image/png' }
      ]
    });
    
    navigator.mediaSession.setActionHandler('play', () => {
      const audio = document.getElementById('audio');
      if (audio) audio.play();
      updatePlayPauseIcon();
    });
    
    navigator.mediaSession.setActionHandler('pause', () => {
      const audio = document.getElementById('audio');
      if (audio) audio.pause();
      updatePlayPauseIcon();
    });
    
    navigator.mediaSession.setActionHandler('stop', () => {
      stopPlayback();
    });
    
    navigator.mediaSession.setActionHandler('previoustrack', () => {
      previousTrack();
    });
    
    navigator.mediaSession.setActionHandler('nexttrack', () => {
      nextTrack();
    });
    
    navigator.mediaSession.setActionHandler('seekto', (details) => {
      const audio = document.getElementById('audio');
      if (audio) audio.currentTime = details.seekTime;
    });
    
    navigator.mediaSession.setActionHandler('seekbackward', () => {
      const audio = document.getElementById('audio');
      if (audio) audio.currentTime = Math.max(0, audio.currentTime - 10);
    });
    
    navigator.mediaSession.setActionHandler('seekforward', () => {
      const audio = document.getElementById('audio');
      if (audio) audio.currentTime = Math.min(audio.duration, audio.currentTime + 10);
    });
  }
}

// ==================== КАРАОКЕ ====================
function loadLyrics(file) {
  fetch(file)
    .then(r => r.json())
    .then(js => {
      currentLyrics = js;
      renderLyrics(0);
    })
    .catch(err => {
      console.error('Failed to load lyrics:', err);
      currentLyrics = [];
    });
}

function renderLyrics(time) {
  if (!currentLyrics || !currentLyrics.length) {
    const lyricsEl = document.getElementById('lyrics');
    if (lyricsEl) lyricsEl.innerHTML = "";
    return;
  }
  
  let active = 0;
  for (let i = 0; i < currentLyrics.length; i++) {
    if (time >= currentLyrics[i].time) active = i;
  }
  
  const windowSize = 5;
  const start = active < 2 ? 0 : active - 2;
  const padTop = active < 2 ? 2 - active : 0;
  const rows = [];
  
  for (let p = 0; p < padTop; ++p) {
    rows.push('<div class="lyrics-window-line"></div>');
  }
  
  for (let i = start; i < Math.min(currentLyrics.length, start + windowSize - padTop); i++) {
    const cls = (i === active) ? 'lyrics-window-line active' : 'lyrics-window-line';
    rows.push(`<div class="${cls}">${currentLyrics[i] ? currentLyrics[i].line : ""}</div>`);
  }
  
  while (rows.length < windowSize) {
    rows.push('<div class="lyrics-window-line"></div>');
  }
  
  const lyricsEl = document.getElementById("lyrics");
  if (lyricsEl) lyricsEl.innerHTML = rows.join("");
}

// Функция копирования полного текста
function copyLyrics() {
  if (!config || currentTrack < 0 || !config.tracks[currentTrack].fulltext) {
    NotificationSystem.warning("Файл с текстом не найден!");
    return;
  }
  
  fetch(config.tracks[currentTrack].fulltext)
    .then(r => {
      if (!r.ok) throw new Error("Не найден");
      return r.text();
    })
    .then(txt => {
      if (navigator.clipboard && window.isSecureContext) {
        navigator.clipboard.writeText(txt).then(
          () => NotificationSystem.success("Текст песни скопирован!"),
          () => NotificationSystem.error("Не удалось скопировать")
        );
      } else {
        const textarea = document.createElement("textarea");
        textarea.value = txt;
        document.body.appendChild(textarea);
        textarea.select();
        try {
          document.execCommand('copy');
          NotificationSystem.success("Текст песни скопирован!");
        } catch(e) {
          NotificationSystem.error("Не удалось скопировать");
        }
        document.body.removeChild(textarea);
      }
    })
    .catch(() => {
      NotificationSystem.error("Не удалось загрузить текст!");
    });
}
// ==================== КЛАВИАТУРНАЯ НАВИГАЦИЯ (ОБНОВЛЕНО) ====================
window.addEventListener('keydown', function(e) {
  // Проверяем, что фокус не в поле ввода
  if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
    return;
  }
  
  // Проверяем наличие модальных окон
  const hasActiveModal = document.querySelector('.modal-bg.active');
  
  // Esc закрывает модальные окна
  if (e.key === 'Escape' && hasActiveModal) {
    e.preventDefault();
    document.querySelectorAll('.modal-bg.active').forEach(modal => {
      modal.classList.remove('active');
    });
    return;
  }
  
  // Остальные клавиши не работают при открытых модальных окнах
  if (hasActiveModal) return;
  
  const audio = document.getElementById('audio');
  
  switch(e.key.toUpperCase()) {
    // Воспроизведение
    case ' ': // Пробел
    case 'K':
      e.preventDefault();
      togglePlayPause();
      break;
      
    case 'X':
      e.preventDefault();
      stopPlayback();
      break;
      
    case 'N':
      e.preventDefault();
      nextTrack();
      break;
      
    case 'P':
      e.preventDefault();
      previousTrack();
      break;
      
    case 'J':
      e.preventDefault();
      if (audio) audio.currentTime = Math.max(0, audio.currentTime - 10);
      break;
      
    case 'L':
      e.preventDefault();
      if (audio) audio.currentTime = Math.min(audio.duration, audio.currentTime + 10);
      break;
      
    // Громкость
    case '+':
    case '=':
      e.preventDefault();
      const slider = document.getElementById('volume-slider');
      if (slider) {
        slider.value = Math.min(100, parseInt(slider.value) + 10);
        slider.dispatchEvent(new Event('input'));
      }
      break;
      
    case '-':
      e.preventDefault();
      const sliderMinus = document.getElementById('volume-slider');
      if (sliderMinus) {
        sliderMinus.value = Math.max(0, parseInt(sliderMinus.value) - 10);
        sliderMinus.dispatchEvent(new Event('input'));
      }
      break;
      
    case 'M':
      e.preventDefault();
      toggleMute();
      break;
      
    case '0':
      e.preventDefault();
      toggleMute();
      break;
      
    // Режимы
    case 'R':
      e.preventDefault();
      toggleRepeat();
      break;
      
    case 'U':
      e.preventDefault();
      toggleShuffle();
      break;
      
    case 'F':
      if (e.shiftKey) {
        e.preventDefault();
        toggleFavoritesFilter();
      } else {
        e.preventDefault();
        toggleFavoritesOnly();
      }
      break;
      
    case 'T':
      e.preventDefault();
      toggleSleepMenu();
      break;
      
    // Анимации
    case 'A':
      e.preventDefault();
      toggleAnimation();
      break;
      
    case 'B':
      e.preventDefault();
      toggleBit();
      break;
      
    case '1':
      e.preventDefault();
      if (bitEnabled) {
        bitIntensity = 100;
        localStorage.setItem('bitIntensity', '100');
        NotificationSystem.info('💿 Интенсивность пульсации: 100%');
      }
      break;
      
    case '2':
      e.preventDefault();
      if (bitEnabled) {
        bitIntensity = 50;
        localStorage.setItem('bitIntensity', '50');
        NotificationSystem.info('💿 Интенсивность пульсации: 50%');
      }
      break;
      
    case '3':
      e.preventDefault();
      if (bitEnabled) {
        bitIntensity = 15;
        localStorage.setItem('bitIntensity', '15');
        NotificationSystem.info('💿 Интенсивность пульсации: 15%');
      }
      break;
      
    // Интерфейс
    case 'Y':
      e.preventDefault();
      if (currentTrack >= 0) {
        toggleLyricsView();
      }
      break;
      
    case 'W':
      e.preventDefault();
      // Прокручиваем к плейлисту
      document.getElementById('track-list')?.scrollIntoView({ behavior: 'smooth' });
      break;
      
    case 'D':
      e.preventDefault();
      if (currentTrack >= 0) {
        toggleLike(currentTrack);
      }
      break;
      
    case '/':
      e.preventDefault();
      // Фокус на поиск (если будет добавлен в будущем)
      NotificationSystem.info('Поиск будет добавлен в следующей версии');
      break;
      
    case '?':
      e.preventDefault();
      showHotkeysModal();
      break;
      
    case 'V':
      if (e.shiftKey) {
        e.preventDefault();
        const volumeSlider = document.getElementById('volume-slider');
        if (volumeSlider) {
          volumeSlider.value = 50;
          volumeSlider.dispatchEvent(new Event('input'));
          NotificationSystem.info('Громкость установлена на 50%');
        }
      }
      break;
      
    // Навигация по спискам
    case ',':
      e.preventDefault();
      window.scrollBy(0, -100);
      break;
      
    case '.':
      e.preventDefault();
      window.scrollBy(0, 100);
      break;
      
    case '[':
      e.preventDefault();
      if (config && config.tracks.length > 0) {
        showTrack(0, true);
      }
      break;
      
    case ']':
      e.preventDefault();
      if (config && config.tracks.length > 0) {
        showTrack(config.tracks.length - 1, true);
      }
      break;
  }
  
  // Цифровые клавиши для быстрого перехода
  if (e.key >= '1' && e.key <= '9' && !e.shiftKey && !e.ctrlKey && !e.altKey) {
    const trackIndex = parseInt(e.key) - 1;
    if (trackIndex < config.tracks.length) {
      e.preventDefault();
      showTrack(trackIndex, true);
    }
  }
});

// ==================== DEEP LINKS ====================
function parseDeepLink() {
  const params = new URLSearchParams(window.location.search);
  
  const trackParam = params.get('track');
  if (trackParam) {
    const trackIndex = parseInt(trackParam, 10);
    if (trackIndex >= 0 && trackIndex < config.tracks.length) {
      showTrack(trackIndex, true);
      
      setTimeout(() => {
        document.getElementById(`trk${trackIndex}`)?.scrollIntoView({
          behavior: 'smooth',
          block: 'center'
        });
      }, 300);
    }
  }
  
  const timeParam = params.get('time');
  if (timeParam) {
    setTimeout(() => {
      const audio = document.getElementById('audio');
      if (audio) {
        audio.currentTime = parseInt(timeParam, 10);
      }
    }, 1000);
  }
  
  // Поддержка shortcuts из manifest
  const viewParam = params.get('view');
  if (viewParam === 'favorites') {
    setTimeout(() => {
      if (getLiked().length > 0) {
        toggleFavoritesFilter();
      }
    }, 1000);
  }
  
  const shuffleParam = params.get('shuffle');
  if (shuffleParam === '1') {
    shuffleMode = true;
    localStorage.setItem('shuffleMode', '1');
  }
}

function getShareLink(trackIndex) {
  const baseUrl = window.location.origin + window.location.pathname;
  const audio = document.getElementById('audio');
  const time = audio ? Math.floor(audio.currentTime) : 0;
  
  return `${baseUrl}?track=${trackIndex}${time > 10 ? `&time=${time}` : ''}`;
}

// ==================== СКАЧИВАНИЕ ТРЕКОВ ====================
function getTrackFileName(track, idx, artist) {
  return `${(idx + 1).toString().padStart(2, '0')} - ${track.title} - ${artist}.mp3`
    .replace(/[\\/:"*?<>|]+/g, '_');
}

function openDownloadModal(e) {
  if (e) e.preventDefault();
  
  const tr = config.tracks[currentTrack];
  const fileName = getTrackFileName(tr, currentTrack, config.artist);
  const filenameEl = document.getElementById('download-modal-filename');
  if (filenameEl) filenameEl.innerHTML = `<b>${fileName}</b>`;
  document.getElementById('download-modal').classList.add('active');
}

function closeDownloadModal() {
  document.getElementById('download-modal').classList.remove('active');
}

document.getElementById('download-modal').onclick = function(e) {
  if (e.target === this) closeDownloadModal();
};

function downloadCurrentTrack() {
  const tr = config.tracks[currentTrack];
  const fileName = getTrackFileName(tr, currentTrack, config.artist);
  const url = tr.audio;
  
  const a = document.createElement('a');
  a.href = url;
  a.download = fileName;
  document.body.appendChild(a);
  a.click();
  window.setTimeout(() => {
    document.body.removeChild(a);
  }, 250);
  closeDownloadModal();
  NotificationSystem.success('Файл будет загружен!');
}

async function shareCurrentTrack() {
  const track = config.tracks[currentTrack];
  const shareUrl = getShareLink(currentTrack);
  const shareText = `🎵 ${track.title} - ${config.artist}\n🎧 Слушай на:`;
  
  if (navigator.share) {
    try {
      await navigator.share({
        title: track.title,
        text: shareText,
        url: shareUrl
      });
      NotificationSystem.success('Ссылка отправлена!');
      closeDownloadModal();
    } catch (e) {
      // Пользователь отменил
    }
  } else {
    navigator.clipboard.writeText(`${shareText}\n${shareUrl}`);
    NotificationSystem.success('Ссылка скопирована!');
  }
}

async function openInAppCurrentTrack() {
  await shareCurrentTrack();
}

// Функция копирования прямой ссылки на MP3
function copyLinkCurrentTrack() {
  const track = config.tracks[currentTrack];
  const baseUrl = window.location.origin + window.location.pathname.replace('index.html', '');
  const directUrl = baseUrl + track.audio;
  
  if (navigator.clipboard && window.isSecureContext) {
    navigator.clipboard.writeText(directUrl).then(
      () => NotificationSystem.success('Прямая ссылка на MP3 скопирована!'),
      () => NotificationSystem.error('Не удалось скопировать ссылку')
    );
  } else {
    const textarea = document.createElement("textarea");
    textarea.value = directUrl;
    document.body.appendChild(textarea);
    textarea.select();
    try {
      document.execCommand('copy');
      NotificationSystem.success('Прямая ссылка на MP3 скопирована!');
    } catch(e) {
      NotificationSystem.error('Не удалось скопировать ссылку');
    }
    document.body.removeChild(textarea);
  }
  closeDownloadModal();
}

// ==================== СКАЧИВАНИЕ АЛЬБОМА ====================
function loadJSZip() {
  if (window.JSZip) return Promise.resolve();
  return new Promise((resolve, reject) => {
    const script = document.createElement('script');
    script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
    script.onload = resolve;
    script.onerror = reject;
    document.head.appendChild(script);
  });
}

function initializeAlbumDownloadCheckboxes() {
  const onlyFavCheckbox = document.getElementById('onlyFavorites');
  const fullAlbumCheckbox = document.getElementById('fullAlbum');
  
  onlyFavCheckbox.addEventListener('change', function() {
    if (this.checked) {
      fullAlbumCheckbox.checked = false;
      const likedTracks = getLiked();
      if (likedTracks.length === 0) {
        this.checked = false;
        NotificationSystem.warning('Нет избранных треков для скачивания');
      }
    }
  });
  
  fullAlbumCheckbox.addEventListener('change', function() {
    if (this.checked) {
      onlyFavCheckbox.checked = false;
    }
  });
  
  checkFavoritesAvailable();
}

function checkFavoritesAvailable() {
  const favCheckbox = document.getElementById('onlyFavorites');
  const likedTracks = getLiked();
  
  if (likedTracks.length === 0) {
    favCheckbox.disabled = true;
    favCheckbox.parentElement.style.opacity = '0.5';
    favCheckbox.parentElement.title = 'Нет избранных треков';
  } else {
    favCheckbox.disabled = false;
    favCheckbox.parentElement.style.opacity = '1';
    favCheckbox.parentElement.title = `Избранных: ${likedTracks.length}`;
  }
}

function openAlbumDownloadModal() {
  closeDownloadModal();
  checkFavoritesAvailable();
  document.getElementById('albumDownloadModal').classList.add('active');
}

function closeAlbumDownloadModal() {
  document.getElementById('albumDownloadModal').classList.remove('active');
}

document.getElementById('albumDownloadModal').onclick = function(e) {
  if (e.target === this) closeAlbumDownloadModal();
};

// Функция подготовки файлов
async function prepareFilesList() {
  filesToDownload = [];
  const addedFiles = new Set();
  
  let trackIndices = [];
  const likedTracks = getLiked();
  
  if (downloadOptions.onlyFavorites && likedTracks.length > 0) {
    trackIndices = likedTracks;
  } else if (downloadOptions.fullAlbum) {
    trackIndices = config.tracks.map((_, i) => i);
  }
  
  for (let idx of trackIndices) {
    const track = config.tracks[idx];
    const num = String(idx + 1).padStart(2, '0');
    const mp3FileName = `${num} - ${track.title} - ${config.artist}.mp3`;
    
    if (!addedFiles.has(mp3FileName)) {
      addedFiles.add(mp3FileName);
      filesToDownload.push({
        url: track.audio,
        name: mp3FileName,
        type: 'audio'
      });
    }
    
    if (downloadOptions.includeLyrics && track.fulltext) {
      const lyricsName = `${num} - ${track.title} - ${config.artist}.txt`;
      
      if (!addedFiles.has(lyricsName)) {
        addedFiles.add(lyricsName);
        try {
          const response = await fetch(track.fulltext);
          const text = await response.text();
          filesToDownload.push({
            content: text,
            name: lyricsName,
            type: 'text'
          });
        } catch(e) {
          console.error('Не удалось загрузить текст для', track.title);
        }
      }
    }
  }
  
  if (downloadOptions.includeCovers) {
    coverGalleryArr.forEach(cover => {
      const coverName = cover.split('/').pop();
      if (!addedFiles.has(coverName)) {
        addedFiles.add(coverName);
        filesToDownload.push({
          url: cover,
          name: coverName,
          type: 'image'
        });
      }
    });
  }
  
  if (!addedFiles.has('logo.png')) {
    filesToDownload.push({
      url: 'img/logo.png',
      name: 'logo.png',
      type: 'image'
    });
  }
  
  if (!addedFiles.has('social.txt')) {
    filesToDownload.push({
      content: generateSocialText(),
      name: 'social.txt',
      type: 'text'
    });
  }
  
  console.log(`Подготовлено ${filesToDownload.length} файлов для архива`);
}

function generateSocialText() {
  const socials = config.socials || [];
  let socialLinks = '';
  
  socials.forEach(social => {
    socialLinks += `${social.title}: ${social.url}\n`;
  });
  
  return `═══════════════════════════════════════
       ВИТРИНА РАЗБИТА - Между Злом и Добром
═══════════════════════════════════════

Спасибо за интерес к нашему творчеству!
Ваша поддержка очень важна для нас.

Подписывайтесь на наши социальные сети:

${socialLinks}
Делитесь музыкой с друзьями!
С любовью, группа "Витрина Разбита"

═══════════════════════════════════════`;
}
async function prepareDownload() {
  downloadOptions.includeCovers = document.getElementById('includeCovers').checked;
  downloadOptions.includeLyrics = document.getElementById('includeLyrics').checked;
  downloadOptions.onlyFavorites = document.getElementById('onlyFavorites').checked;
  downloadOptions.fullAlbum = document.getElementById('fullAlbum').checked;
  
  if (!downloadOptions.onlyFavorites && !downloadOptions.fullAlbum) {
    NotificationSystem.warning('Выберите треки для скачивания');
    return;
  }
  
  if (downloadOptions.onlyFavorites && getLiked().length === 0) {
    NotificationSystem.warning('Нет избранных треков для скачивания');
    return;
  }
  
  await loadJSZip();
  await prepareFilesList();
  
  if (filesToDownload.length === 0) {
    NotificationSystem.error('Нет файлов для создания архива');
    return;
  }
  
  const sizeMB = await calculateArchiveSize();
  
  document.getElementById('archiveSize').textContent = sizeMB + ' МБ';
  document.getElementById('fileCount').textContent = filesToDownload.length;
  
  closeAlbumDownloadModal();
  document.getElementById('sizeConfirmModal').classList.add('active');
}

// Функция расчёта размера архива
async function calculateArchiveSize() {
  let totalSize = 0;
  const promises = [];
  
  for (let file of filesToDownload) {
    if (file.url) {
      const headPromise = fetch(file.url, { method: 'HEAD' })
        .then(response => {
          const size = response.headers.get('content-length');
          return size ? parseInt(size) : null;
        })
        .catch(() => null);
      
      const heuristicPromise = new Promise(resolve => {
        setTimeout(() => {
          if (file.type === 'audio') resolve(4.7 * 1024 * 1024);
          else if (file.type === 'image') resolve(500 * 1024);
          else if (file.type === 'text') resolve(5 * 1024);
          else resolve(100 * 1024);
        }, 500);
      });
      
      promises.push(
        Promise.race([headPromise, heuristicPromise]).then(size => {
          if (size) totalSize += size;
        })
      );
    } else if (file.content) {
      totalSize += new Blob([file.content]).size;
    }
  }
  
  await Promise.allSettled(promises);
  
  totalSize = Math.ceil(totalSize * 1.1);
  
  const sizeMB = (totalSize / 1024 / 1024).toFixed(1);
  
  if (sizeMB < 0.1) {
    return "~" + (filesToDownload.length * 0.5).toFixed(1);
  }
  if (sizeMB > 500) {
    return "~" + Math.min(sizeMB, 200).toFixed(1);
  }
  
  return sizeMB;
}

function closeSizeConfirmModal() {
  document.getElementById('sizeConfirmModal').classList.remove('active');
}

document.getElementById('sizeConfirmModal').onclick = function(e) {
  if (e.target === this) closeSizeConfirmModal();
};

function startDownload() {
  closeSizeConfirmModal();
  createAndDownloadZip();
}

function showProgressModal() {
  document.getElementById('downloadProgressModal').classList.add('active');
  document.getElementById('progressFill').style.width = '0%';
  document.getElementById('progressText').textContent = 'Загрузка файлов: 0/' + filesToDownload.length;
  document.getElementById('errorsList').style.display = 'none';
}

function updateProgress(completed, total) {
  const percent = Math.round((completed / total) * 100);
  document.getElementById('progressFill').style.width = percent + '%';
  document.getElementById('progressText').textContent = `Загрузка файлов: ${completed}/${total}`;
}

function showErrors(errors) {
  if (errors.length > 0) {
    document.getElementById('errorsList').style.display = 'block';
    document.getElementById('errorsListContent').innerHTML = errors.map(e => `<li>${e}</li>`).join('');
  }
}

// Функция создания и скачивания ZIP архива
async function createAndDownloadZip() {
  if (!window.JSZip) {
    await loadJSZip();
  }
  
  const zip = new JSZip();
  const errors = [];
  let completed = 0;
  
  showProgressModal();
  
  // Параллельная загрузка с ограничением
  const BATCH_SIZE = 5;
  
  for (let i = 0; i < filesToDownload.length; i += BATCH_SIZE) {
    const batch = filesToDownload.slice(i, i + BATCH_SIZE);
    
    await Promise.allSettled(
      batch.map(async file => {
        try {
          if (file.url) {
            const response = await fetch(file.url);
            if (!response.ok) throw new Error(`HTTP ${response.status}`);
            const blob = await response.blob();
            zip.file(file.name, blob);
          } else if (file.content) {
            zip.file(file.name, file.content);
          }
          
          completed++;
          updateProgress(completed, filesToDownload.length);
          
        } catch (error) {
          errors.push(file.name);
          console.error(`Ошибка загрузки ${file.name}:`, error);
          completed++;
          updateProgress(completed, filesToDownload.length);
        }
      })
    );
  }
  
  if (errors.length > 0) {
    showErrors(errors);
    await new Promise(resolve => setTimeout(resolve, 2000));
  }
  
  document.getElementById('progressText').textContent = 'Создание архива...';
  
  const content = await zip.generateAsync({
    type: "blob",
    compression: "DEFLATE",
    compressionOptions: { level: 6 },
    streamFiles: true
  }, function updateCallback(metadata) {
    const progress = metadata.percent.toFixed(0);
    document.getElementById('progressText').textContent = `Создание архива: ${progress}%`;
    document.getElementById('progressFill').style.width = progress + '%';
  });
  
  const link = document.createElement('a');
  link.href = URL.createObjectURL(content);
  
  const date = new Date().toISOString().split('T')[0];
  link.download = `vitrina-razbita-${date}.zip`;
  
  link.click();
  
  setTimeout(() => {
    document.getElementById('downloadProgressModal').classList.remove('active');
    NotificationSystem.success('Архив успешно скачан!');
    URL.revokeObjectURL(link.href);
  }, 1500);
}

// ==================== ОФЛАЙН РЕЖИМ ====================
function offlineUIClick() {
  if (offlineDownloading) return;
  
  if (!offlineMode) {
    document.getElementById('modal-offline').classList.add('active');
    document.getElementById('offline-step').innerHTML = `
      <div style="font-size:1.09em;font-weight:700;margin-bottom:10px;">Оффлайн-режим</div>
      <div style="margin-bottom:16px;">Для работы без интернета нужно скачать музыку на устройство.<br>
      Это займёт <b>место</b> и время.<br>
      <div style="color:#e80100;margin:5px 0 0 0;">
        ⚠ На некоторых устройствах (iOS Safari) размер может быть ограничен (~50-150 МБ).
      </div>
      <div style="margin:8px 0 0 0;opacity:.7;">
        После скачивания вы сможете слушать OFFLINE-файлы без интернет-соединения.
      </div>
      </div>
      <button class="offline-btn online" style="width:99%;margin-bottom:7px;" onclick="nextOfflineChoice()">Согласен</button>
      <button class="offline-btn" style="width:99%;" onclick="closeOfflineModal()">Отмена</button>`;
  } else {
    document.getElementById('modal-offline').classList.add('active');
    document.getElementById('offline-step').innerHTML = `
      <div style="font-size:1.10em;font-weight:700;margin-bottom:15px;">Вернуться в ONLINE?</div>
      <div style="margin-bottom:20px;">Все скачанные файлы будут удалены.<br>
      Очищается место на устройстве.<br>
      Песни снова будут доступны только через интернет.
      </div>
      <button class="offline-btn online" style="width:99%;" onclick="confirmGoOnline()">Удалить файлы и возврат ONLINE</button>
      <button class="offline-btn" style="width:99%;margin-top:7px;" onclick="closeOfflineModal()">Отмена</button>`;
  }
}

function closeOfflineModal() {
  document.getElementById('modal-offline').classList.remove('active');
}

function nextOfflineChoice() {
  const d = getDownloadStats();
  document.getElementById('offline-step').innerHTML = `
    <div style="font-size:1.10em;font-weight:700;margin-bottom:13px;">Что скачать?</div>
    <div style="text-align:left;">
      <label style="display:block;margin:8px 0;">
        <input type="radio" name="offline-mode" value="all" checked>
        Весь диск (${d.allCount} песен, ${d.allSizeMb} МБ)
      </label>
      <label style="display:block;margin:8px 0;">
        <input type="radio" name="offline-mode" value="liked">
        Только понравившиеся (${d.likedCount || 0} песен, ${d.likedSizeMb || 0} МБ)
      </label>
    </div>
    <button class="offline-btn online" style="width:99%;margin-top:12px;" onclick="startOfflineDownload()">Скачать выбранное</button>
    <button class="offline-btn" style="width:99%;margin-top:8px;" onclick="closeOfflineModal()">Отмена</button>`;
}

function getAudioSize(idx) {
  return config.tracks[idx].size || 4.7;
}

function getDownloadStats() {
  const liked = getLiked();
  const allCount = config.tracks.length;
  const likedCount = liked.length;
  
  let allMb = 0, likeMb = 0;
  for (let i = 0; i < allCount; ++i) {
    allMb += getAudioSize(i);
    if (liked.indexOf(i) !== -1) likeMb += getAudioSize(i);
  }
  
  return {
    allSizeMb: Math.round(allMb * 10) / 10,
    likedSizeMb: Math.round(likeMb * 10) / 10,
    likedCount,
    allCount
  };
}

function getAllAssetsForOffline(mode) {
  const all = ['index.html', 'config.json', 'img/logo.png', 'img/star.png', 'img/star2.png',
               'Cover.png', 'Cover01.png', 'Cover02.png', 'Cover03.png'];
  const liked = getLiked();
  
  for (let i = 0; i < config.tracks.length; ++i) {
    if (mode === 'all' || liked.indexOf(i) !== -1) {
      all.push(config.tracks[i].audio);
      all.push(config.tracks[i].lyrics);
      if (config.tracks[i].fulltext) all.push(config.tracks[i].fulltext);
    }
  }
  
  return [...new Set(all)];
}

function startOfflineDownload() {
  offlineDownloading = true;
  closeOfflineModal();
  setOfflineUIState('downloading');
  
  const mode = document.querySelector('input[name="offline-mode"]:checked').value;
  const files = getAllAssetsForOffline(mode);
  
  navigator.serviceWorker.ready.then(async sw => {
    sw.active.postMessage({
      type: 'CACHE_FILES',
      files,
      offlineMode: true
    });
    
    const stats = getDownloadStats();
    const needMb = (mode == 'all' ? stats.allSizeMb : stats.likedSizeMb);
    const max = files.length;
    
    const checkAll = setInterval(async () => {
      const cache = await caches.open('album-offline-v1');
      let ok = 0;
      
      for (let src of files) {
        const res = await cache.match(src);
        if (res) ok++;
      }
      
      setOfflineUIState('downloading', ok / max, needMb);
      
      if (ok >= max) {
        clearInterval(checkAll);
        offlineDownloading = false;
        offlineMode = true;
        localStorage.setItem('offlineMode', '1');
        setOfflineUIState('offline');
        offlineShowDone(needMb, mode);
        syncOfflineState();
      }
    }, 400);
  });
}

function setOfflineUIState(state, progress, needMb) {
  const btn = document.getElementById('offline-btn');
  
  if (state === 'downloading') {
    btn.disabled = true;
    btn.className = 'offline-btn offline';
    btn.innerHTML = 'OFFLINE';
    
    if (!document.getElementById('offline-progr-div')) {
      const div = document.createElement('div');
      div.id = 'offline-progr-div';
      div.innerHTML = `
        <div class="offline-progress">
          <div class="offline-progress-bar" id="offline-progress-bar" style="width:0%;"></div>
        </div>
        <div class="offline-desc" id="offline-desc"></div>`;
      btn.parentElement.insertBefore(div, btn.nextSibling);
    }
    
    document.getElementById('offline-progress-bar').style.width = Math.round((progress || 0) * 100) + '%';
    document.getElementById('offline-desc').innerText = "Загружается приблизительно " + (needMb || 0) + " МБ ...";
  }
  
  if (state === 'offline') {
    btn.disabled = false;
    btn.className = 'offline-btn offline';
    btn.innerHTML = 'OFFLINE';
    const div = document.getElementById('offline-progr-div');
    if (div) div.remove();
  }
  
  if (state === 'online') {
    btn.disabled = false;
    btn.className = 'offline-btn online';
    btn.innerHTML = 'ONLINE';
    const div = document.getElementById('offline-progr-div');
    if (div) div.remove();
  }
}

function offlineShowDone(mb, mode) {
  document.getElementById('modal-offline').classList.add('active');
  document.getElementById('offline-step').innerHTML = `
    <div style="font-size:1.18em;font-weight:700;margin-bottom:12px;">Все файлы скачаны!</div>
    <div style="margin-bottom:13px;">
      <b>${mode == "all" ? "Весь диск" : "Понравившиеся треки"}</b><br>
      Доступны без интернета.<br>
      Загружено примерно <b>${mb} МБ</b>.<br>
      <div style="color:#888;font-size:.98em;margin:5px 0 0 0;">
        Обратите внимание: если кеш браузера<br>будет очищен — нужно будет скачать заново!
      </div>
    </div>
    <button class="offline-btn" style="width:99%;" onclick="closeOfflineModal()">OK</button>`;
}

function confirmGoOnline() {
  offlineMode = false;
  localStorage.removeItem('offlineMode');
  setOfflineUIState('online');
  closeOfflineModal();
  
  navigator.serviceWorker.ready.then(sw => {
    sw.active.postMessage({
      type: 'CLEAR_CACHE',
      offlineMode: false
    });
  });
}

// ==================== iOS ПОДДЕРЖКА И PWA ====================
function detectIOSAndShowInstallGuide() {
  const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
  const isInStandaloneMode = window.navigator.standalone === true;
  const isInPWA = window.matchMedia('(display-mode: standalone)').matches;
  
  if (isIOS && !isInStandaloneMode && !isInPWA) {
    if (!localStorage.getItem('ios-install-dismissed')) {
      setTimeout(showIOSInstallPrompt, 2000);
    }
  }
}

function showIOSInstallPrompt() {
  const prompt = document.createElement('div');
  prompt.className = 'ios-install-prompt';
  prompt.innerHTML = `
    <div class="ios-prompt-content">
      <button class="ios-prompt-close" onclick="dismissIOSPrompt()">×</button>
      <img src="img/logo.png" alt="Logo" class="ios-prompt-icon">
      <h3>Установить приложение</h3>
      <p>Установите это приложение на свой iPhone:</p>
      <ol style="text-align: left;">
        <li>Нажмите «Поделиться» внизу экрана</li>
        <li>Прокрутите и выберите «На экран Домой»</li>
        <li>Нажмите «Добавить»</li>
      </ol>
      <button onclick="dismissIOSPrompt()" class="ios-prompt-button">Понятно</button>
    </div>
  `;
  document.body.appendChild(prompt);
  
  setTimeout(() => prompt.classList.add('show'), 100);
}

function dismissIOSPrompt() {
  const prompt = document.querySelector('.ios-install-prompt');
  if (prompt) {
    prompt.classList.remove('show');
    setTimeout(() => prompt.remove(), 300);
    localStorage.setItem('ios-install-dismissed', Date.now().toString());
  }
}

// PWA установка
window.addEventListener('beforeinstallprompt', (e) => {
  e.preventDefault();
  deferredPrompt = e;
  const btn = document.getElementById('install-pwa-btn');
  if (btn) btn.style.display = '';
});

document.getElementById('install-pwa-btn').onclick = function() {
  document.getElementById('install-modal').classList.add('active');
  document.getElementById('install-modal-hash').style.display = 'none';
  document.getElementById('install-proceed-btn').disabled = false;
  document.getElementById('install-proceed-btn').innerText = 'Установить';
};

function closeInstallModal() {
  document.getElementById('install-modal').classList.remove('active');
}

document.getElementById('install-proceed-btn').onclick = async function() {
  const btn = this;
  btn.disabled = true;
  btn.innerText = 'Выполняется проверка...';
  document.getElementById('install-modal-hash').style.display = '';
  document.getElementById('install-hash-progress').innerText = '';
  
  const hash = await hashManifest();
  document.getElementById('install-hash-progress').innerText = 'SHA-256: ' + hash;
  btn.innerText = 'Установка...';
  
  if (deferredPrompt) {
    deferredPrompt.prompt();
    deferredPrompt.userChoice.then((choiceResult) => {
      closeInstallModal();
      document.getElementById('install-pwa-btn').style.display = 'none';
      deferredPrompt = null;
    });
  } else {
    alert('К сожалению, ваш браузер не поддерживает установку PWA.');
    closeInstallModal();
  }
};

async function hashManifest() {
  try {
    const resp = await fetch('manifest.json');
    const data = await resp.arrayBuffer();
    const hashBuffer = await crypto.subtle.digest('SHA-256', data);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
  } catch(e) {
    return '[ошибка хэширования]';
  }
}

document.getElementById('install-modal').onclick = function(e) {
  if (e.target === this) closeInstallModal();
};

// ==================== ОБРАТНАЯ СВЯЗЬ ====================
let isRealTextarea = false;

function openFeedbackModal() {
  document.getElementById('modal-feedback').classList.add('active');
  isRealTextarea = false;
  document.getElementById('feedback-step').innerHTML = `
    <div class="fake-textarea" id="fake-textarea" onclick="showRealTextarea()">
      Опишите здесь проблему или своё пожелание для улучшения,<br>можете просто оставить свой отзыв...
    </div>`;
  document.getElementById('modal-feedback-error').innerText = "";
  document.getElementById('modal-feedback-success').innerText = "";
  document.getElementById('send-feedback-btn').disabled = false;
}

function closeFeedbackModal() {
  document.getElementById('modal-feedback').classList.remove('active');
}

function showRealTextarea() {
  if (isRealTextarea) return;
  isRealTextarea = true;
  document.getElementById('feedback-step').innerHTML = 
    `<textarea class="real-textarea" id="feedback-text" maxlength="200" autofocus></textarea>`;
  
  setTimeout(() => {
    const ta = document.getElementById('feedback-text');
    ta.focus();
    ta.addEventListener('input', function() {
      if (this.value.length > 200) this.value = this.value.substr(0, 200);
    });
  }, 20);
}

function sendFeedbackMsg() {
  let msg = "";
  if (isRealTextarea) {
    const ta = document.getElementById('feedback-text');
    msg = ta.value.trim();
  } else return;
  
  const errorDiv = document.getElementById('modal-feedback-error');
  const successDiv = document.getElementById('modal-feedback-success');
  
  errorDiv.innerText = "";
  successDiv.innerText = "";
  
  if (msg.length < 5) {
    errorDiv.innerText = "Напишите хотя бы пару слов!";
    return;
  }
  
  document.getElementById('send-feedback-btn').disabled = true;
  successDiv.innerText = "Спасибо! Ваш отзыв принят.";
  setTimeout(closeFeedbackModal, 2100);
}

// ==================== ИНИЦИАЛИЗАЦИЯ ПРИ ЗАГРУЗКЕ ====================
document.addEventListener('DOMContentLoaded', function() {
  // Проверяем поддержку PWA
  if ('serviceWorker' in navigator && 'caches' in window) {
    console.log('PWA features supported');
  } else {
    console.warn('PWA features not fully supported');
  }
  
  // Восстановление настроек плеера
  shuffleMode = localStorage.getItem('shuffleMode') === '1';
  repeatMode = localStorage.getItem('repeatMode') === '1';
  favoritesOnlyMode = localStorage.getItem('favoritesOnlyMode') === '1';
  offlineMode = localStorage.getItem('offlineMode') === '1';
  animationEnabled = localStorage.getItem('animationEnabled') === '1';
  bitEnabled = localStorage.getItem('bitEnabled') === '1';
  
  const savedIntensity = localStorage.getItem('bitIntensity');
  if (savedIntensity) {
    bitIntensity = parseInt(savedIntensity);
  }
  
  hasShownAnimationWarning = localStorage.getItem('hasShownAnimationWarning') === '1';
  hasShownBitWarning = localStorage.getItem('hasShownBitWarning') === '1';
  
  // Инициализация доступных треков
  if (config) {
    updateAvailableTracks();
  }
  
  // Проверяем темную тему системы
  if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
    document.body.classList.add('dark-theme');
  }
  
  // Наблюдатель за изменениями списка треков
  setTimeout(() => {
    const trackList = document.getElementById('track-list');
    if (!trackList) return;
    
    const observer = new MutationObserver((mutations) => {
      if (favoritesFilterActive) {
        updateFavoriteClasses();
      }
    });
    
    observer.observe(trackList, {
      childList: true,
      subtree: true
    });
  }, 1000);
});

// ==================== МОНИТОРИНГ СЕТИ ====================
window.addEventListener('online', () => {
  NotificationSystem.success('Соединение восстановлено');
});

window.addEventListener('offline', () => {
  NotificationSystem.offline('Нет соединения с интернетом');
});

// ==================== PERFORMANCE MONITORING ====================
if (window.performance && performance.mark) {
  performance.mark('app-start');
  
  window.addEventListener('load', () => {
    performance.mark('app-loaded');
    performance.measure('App Load Time', 'app-start', 'app-loaded');
    
    const measure = performance.getEntriesByName('App Load Time')[0];
    console.log(`App loaded in ${measure.duration.toFixed(2)}ms`);
  });
}

// ==================== ОБРАБОТКА ОШИБОК ====================
window.addEventListener('error', (event) => {
  console.error('Global error:', event);
  if (event.message && !event.message.includes('ResizeObserver')) {
    console.error('Debug info at error:', debugInfo());
  }
});

window.addEventListener('unhandledrejection', (event) => {
  console.error('Unhandled promise rejection:', event);
});

// ==================== ОТЛАДКА ====================
window.debugInfo = function() {
  const info = {
    version: VERSION,
    buildDate: BUILD_DATE,
    userAgent: navigator.userAgent,
    online: navigator.onLine,
    serviceWorker: 'serviceWorker' in navigator,
    localStorage: {
      promoPassed: localStorage.getItem('promoPassed'),
      likedTracks: getLiked(),
      shuffleMode: localStorage.getItem('shuffleMode'),
      repeatMode: localStorage.getItem('repeatMode'),
      favoritesOnlyMode: localStorage.getItem('favoritesOnlyMode'),
      favoritesFilter: localStorage.getItem('favoritesFilter'),
      offlineMode: localStorage.getItem('offlineMode'),
      animationEnabled: localStorage.getItem('animationEnabled'),
      bitEnabled: localStorage.getItem('bitEnabled'),
      bitIntensity: localStorage.getItem('bitIntensity')
    },
    config: {
      loaded: configLoaded,
      tracks: config?.tracks?.length || 0,
      artist: config?.artist,
      albumYear: config?.albumYear
    },
    player: {
      currentTrack: currentTrack,
      shuffleMode: shuffleMode,
      repeatMode: repeatMode,
      favoritesOnlyMode: favoritesOnlyMode,
      lyricsViewMode: lyricsViewMode,
      autoPlay: autoPlayEnabled,
      animationEnabled: animationEnabled,
      bitEnabled: bitEnabled,
      bitIntensity: bitIntensity
    },
    cache: {
      caches: 'caches' in window
    }
  };
  
  console.table(info);
  return info;
};

console.log('Application initialized. Version:', VERSION);
</script>

<!-- Ленивая загрузка JSZip только при необходимости -->
<script>
// JSZip будет загружен динамически при первом использовании функции скачивания альбома
</script>

</body>
</html>
